<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kadina&#39;s Blog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://kadina11.github.io/"/>
  <updated>2022-07-04T01:53:06.184Z</updated>
  <id>https://kadina11.github.io/</id>
  
  <author>
    <name>kadina</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Seata分布式事务实战教程</title>
    <link href="2022/06/16/2022-06-16Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/"/>
    <id>2022/06/16/2022-06-16Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/</id>
    <published>2022-06-16T15:22:42.000Z</published>
    <updated>2022-07-04T01:53:06.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综合应用：Seata-分布式事务实战教程"><a href="#综合应用：Seata-分布式事务实战教程" class="headerlink" title="综合应用：Seata 分布式事务实战教程"></a>综合应用：Seata 分布式事务实战教程</h1><p>在前面的章节，我们分别讲解了 Spring Cloud Alibaba 中主要的组成部分，其中包括：注册中心与配置管理组件 Nacos、Ribbon 客户端负载均衡、OpenFeign 与 Dubbo 通信组件、Sentinel 服务限流与熔断保护组件、Sleuth+Zipkin 与 Skywalking 实现分布式追踪、Seata 分布式事务组件以及 RocketMQ 消息异步通信中间件，这些组件各司其职为微服务架构提供了有效的支撑。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/1.png" alt="Spring Cloud Alibaba 中主要的组成部分" loading="lazy"></p><p>从本章开始，我们综合运用这些组件，再结合我多年来分布式开发的经验，为你分享一些成熟的组合搭配与案例，让你在分布式开发这条路上少走些弯路。</p><p>本讲咱们进入第一个话题：利用 Seata 与 Nacos 构建分布式事务架构。之前介绍了Seata 的使用原理及解决方案，但并未涉及落地的开发技巧。今天我们补上这一块内容，我将手把手带你搭建可用的 Seata 分布式事务架构。</p><p>按搭建顺序将分为以下几个阶段：</p><ul><li><p><strong>部署 Nacos 注册中心与配置中心</strong>；</p></li><li><p><strong>部署 TC 组件 Seata-Server</strong>；</p></li><li><p><strong>开发 RM 资源管理器</strong>；</p></li><li><p><strong>开发 TM 事务管理器</strong>；</p></li><li><p><strong>验证分布式事务</strong>。</p></li></ul><p>下面我们一步步实现前面的“商城销售积分”应用案例。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/2.png" alt="案例示意图" loading="lazy"></p><center>案例示意图</center><p>首先咱们来看整体架构图：</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/3.png" alt="基于 Seata 的分布式事务架构" loading="lazy"></p><center>基于 Seata 的分布式事务架构</center><p>我在 192.168.157.138 虚拟机构建了 5 个 MySQL 5.7 数据库实例，通过设置不同端口来模拟 5 台数据库服务器，它们的用途是：</p><ul><li><p>3306 端口数据库存储 Nacos 配置信息以及 Seata-Server 的分布式事务数据；</p></li><li><p>3307 端口数据库存储 TM 端商城数据；</p></li><li><p>3308 端口数据库存储 RM 端订单服务数据；</p></li><li><p>3309 端口数据库存储 RM 端会员积分数据；</p></li><li><p>3310 端口数据库存储 RM 端库存数据。</p></li></ul><p>应用方面包含 6 个节点：</p><ul><li><p>192.168.157.131:8848 节点是 Nacos 注册中心与配置中心服务器，提供微服务架构核心支撑；</p></li><li><p>192.168.157.136:8091 节点是 Seata-Server，也就是 TC 组件，用于协调全局事务的开启、提交与回滚；</p></li><li><p>192.168.157.139:8001 节点是 TM，也就是商城应用，TM用于定义事务边界与事务的范围；</p></li><li><p>192.168.157.140:8002/8003/8004 则是具体的 RM 实例，分别对应订单、积分与库存服务。</p></li></ul><p>其中所有 TM、RM、TC 实例在启动时都要向 Nacos 进行注册登记，以保证服务可以被发现。同时 TC(Seata-Server) 自身的配置信息也要托管在 Nacos 配置中心中，不再单独存储。所有 TM、RM 在启动时也要额外在 TC 中进行注册，以保证全局事务的完整性。</p><p>下面咱们开始第一个阶段：部署 Nacos 注册中心与配置中心。</p><h2 id="部署-Nacos-注册中心与配置中心"><a href="#部署-Nacos-注册中心与配置中心" class="headerlink" title="部署 Nacos 注册中心与配置中心"></a>部署 Nacos 注册中心与配置中心</h2><p>部署 Nacos 注册中心与配置中心与前面课程内容并无二致，咱们快速完成即可。</p><h3 id="第一步，下载-Nacos，上传到-192-168-31-103-节点解压缩。"><a href="#第一步，下载-Nacos，上传到-192-168-31-103-节点解压缩。" class="headerlink" title="第一步，下载 Nacos，上传到 192.168.31.103 节点解压缩。"></a>第一步，下载 Nacos，上传到 192.168.31.103 节点解压缩。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="第二步，配置-conf-application-properties，增加数据库配置。"><a href="#第二步，配置-conf-application-properties，增加数据库配置。" class="headerlink" title="第二步，配置 conf/application.properties，增加数据库配置。"></a>第二步，配置 conf/application.properties，增加数据库配置。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### Count of DB:</span><br><span class="line">db.num=1</span><br><span class="line">### Connect URL of DB:</span><br><span class="line">db.url.0=jdbc:mysql://192.168.157.138:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user=root</span><br><span class="line">db.password=root</span><br></pre></td></tr></table></figure><h3 id="第三步，创建-3309-端口的-nacos-config-数据库，执行-conf-nacos-mysql-sql，完成-Nacos-注册中心表创建。"><a href="#第三步，创建-3309-端口的-nacos-config-数据库，执行-conf-nacos-mysql-sql，完成-Nacos-注册中心表创建。" class="headerlink" title="第三步，创建 3309 端口的 nacos_config 数据库，执行 conf/nacos-mysql.sql，完成 Nacos 注册中心表创建。"></a>第三步，创建 3309 端口的 nacos_config 数据库，执行 conf/nacos-mysql.sql，完成 Nacos 注册中心表创建。</h3><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/4.png" alt="基于 Seata 的分布式事务架构" loading="lazy"></p><center>基于 Seata 的分布式事务架构</center><h3 id="第四步，创建-conf-cluster-conf-集群配置文件，配置一个单节点集群。"><a href="#第四步，创建-conf-cluster-conf-集群配置文件，配置一个单节点集群。" class="headerlink" title="第四步，创建 conf/cluster.conf 集群配置文件，配置一个单节点集群。"></a>第四步，创建 conf/cluster.conf 集群配置文件，配置一个单节点集群。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#it is ip</span><br><span class="line">#example</span><br><span class="line">192.168.157.131:8848</span><br></pre></td></tr></table></figure><h3 id="第五步，运行-startup-脚本，启动-Nacos。"><a href="#第五步，运行-startup-脚本，启动-Nacos。" class="headerlink" title="第五步，运行 startup 脚本，启动 Nacos。"></a>第五步，运行 startup 脚本，启动 Nacos。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /usr/local/nacos/bin/startup.sh</span><br></pre></td></tr></table></figure><p>至此，阶段一：Nacos 注册中心与配置中心部署完成，因为这些内容前面都讲过，所以不再赘述。<br>下面咱们开始阶段二：部署 TC 组件 Seata-Server。</p><p>从部署 TC 组件 Seata-Server 开始就是全新的内容，我将更细致地为你介绍每一步操作过程。</p><h2 id="部署-TC-组件-Seata-Server"><a href="#部署-TC-组件-Seata-Server" class="headerlink" title="部署 TC 组件 Seata-Server"></a>部署 TC 组件 Seata-Server</h2><h3 id="第一步-下载-Seata-Server。"><a href="#第一步-下载-Seata-Server。" class="headerlink" title="第一步 下载 Seata-Server。"></a>第一步 下载 Seata-Server。</h3><p>在 192.168.157.136 设备上安装好 JDK 1.8，之后访问 Seata 的 GitHub，下载最新的 1.4.0 压缩包。</p><p><a class="link" href="https://github.com/seata/seata/releases/download/v1.4.0/seata-server-1.4.0.tar.gz">https://github.com/seata/seata/releases/download/v1.4.0/seata-server-1.4.0.tar.gz<i class="fas fa-external-link-alt"></i></a></p><p>解压后将 seata-server-1.4 上传到 192.168.157.136 节点的 /usr/local 目录下。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/5.png" alt="Seata-Server 目录结构" loading="lazy"></p><center>Seata-Server 目录结构</center><h3 id="第二步-编辑-conf-registry-conf-文件"><a href="#第二步-编辑-conf-registry-conf-文件" class="headerlink" title="第二步 编辑 conf/registry.conf 文件"></a>第二步 编辑 conf/registry.conf 文件</h3><p>这个配置文件说明 Seata-Server 接入哪种注册中心与配置中心，官方提供的默认模板存在大量冗余配置，这里我提供接入 Nacos 最精简的配置内容以方便学习。下面是 Seata-Server 接入注册中心的配置信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # Seata-Server支持以下几种注册中心，这里改为nacos，默认是file文件形式不介入任何注册中心。</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line">  # 负载均衡采用随机策略</span><br><span class="line">  loadBalance = &quot;RandomLoadBalance&quot;</span><br><span class="line">  loadBalanceVirtualNodes = 10</span><br><span class="line">  # nacos注册中心接入配置</span><br><span class="line">  nacos &#123;</span><br><span class="line">    # 应用名称</span><br><span class="line">    application = &quot;seata-server&quot;</span><br><span class="line">    #IP地址与端口</span><br><span class="line">    serverAddr = &quot;192.168.157.131:8848&quot;</span><br><span class="line">    # 分配应用组，采用默认值SEATA_GROUP即可</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    # 集群名称，采用默认值default即可</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    # Nacos接入用户名密码</span><br><span class="line">    username = &quot;nacos&quot;</span><br><span class="line">    password = &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#Seata-Server接入配置中心</span><br><span class="line">config &#123;</span><br><span class="line">  # Seata-Server支持以下配置中心产品，这里设置为nacos，默认是file即文件形式保存配置内容。</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line">  # 设置Nacos的通信地址</span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;192.168.157.131:8848&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    username = &quot;nacos&quot;</span><br><span class="line">    password = &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置文件你可以直接复制到自己工程中修改下 IP 端口即可。</p><h3 id="第三步-在-Nacos-配置中心中初始化-Seata-配置。"><a href="#第三步-在-Nacos-配置中心中初始化-Seata-配置。" class="headerlink" title="第三步 在 Nacos 配置中心中初始化 Seata 配置。"></a>第三步 在 Nacos 配置中心中初始化 Seata 配置。</h3><p>Seata 官方也为我们提供了初始化配置脚本，请按我的步骤操作。</p><p>首先访问下面的地址查看 Seata 在 Nacos 中需要的设置项。</p><p><a class="link" href="https://github.com/seata/seata/blob/1.4.0/script/config-center/config.txt">https://github.com/seata/seata/blob/1.4.0/script/config-center/config.txt<i class="fas fa-external-link-alt"></i></a></p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/6.png" alt="Seata-Server 配置项" loading="lazy"></p><center>Seata-Server 配置项</center><p>将 GitHub 页面中 80 行文本内容复制后，在 /usr/local/seata-server-1.4.0 目录下创建 config.txt 文件，将 80 行文本粘贴其中。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/7.png" alt="config.txt 文件路径" loading="lazy"></p><center>config.txt 文件路径</center><p>在内容粘贴到 config.txt 后，有两个地方需要修改：</p><ul><li><p>34 行 store.mode=file 改为 store.mode=db 代表采用数据库存储 Seata-Server 的全局事务数据</p></li><li><p>44~46 行配置 Seata-Server 的全局事务数据库，数据库 URL 指向 107 节点 3306 端口。这个全局事务数据库是 Seata 维护分布式事务的关键所在，后面咱们马上就要创建这个数据库。</p></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">store.db.url</span>=<span class="string">jdbc:mysql://192.168.157.138:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true</span></span><br><span class="line"><span class="meta">store.db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">store.db.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p>config.txt 保存后，还需要访问下面地址下载 nacos-config.sh 运行脚本。<br><a class="link" href="https://github.com/seata/seata/blob/1.4.0/script/config-center/nacos/nacos-config.sh">https://github.com/seata/seata/blob/1.4.0/script/config-center/nacos/nacos-config.sh<i class="fas fa-external-link-alt"></i></a></p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/8.png" alt="nacos-config.sh" loading="lazy"></p><center>nacos-config.sh</center><p>这个脚本用来读取前面的 config.txt 并将配置项载入 Nacos 配置中心。将页面中 101 行文本复制，然后在 /usr/local/seata-server-1.4.0 目录下创建 script 子目录，在 scirpt 子目录下创建 nacos-config.sh 文件，并将 101 行文本保存其中。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/9.png" alt="nacos-config.sh 文件路径" loading="lazy"></p><center>nacos-config.sh 文件路径</center><p>保存后执行下面命令运行导入脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh nacos-config.sh -h 192.168.157.131</span><br></pre></td></tr></table></figure><p>这条命令有两个参数，h 选项指向 Nacos 的 IP，执行后你会看到如下日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Set metrics.registryType=compact successfully </span><br><span class="line">Set metrics.exporterList=prometheus successfully </span><br><span class="line">Set metrics.exporterPrometheusPort=9898 successfully </span><br><span class="line">=========================================================================</span><br><span class="line"> Complete initialization parameters,  total-count:80 ,  failure-count:0 </span><br><span class="line">=========================================================================</span><br><span class="line"> Init nacos config finished, please start seata-server.</span><br></pre></td></tr></table></figure><p>80 个配置选项导入成功后，我们便可在 Nacos 的配置中心页面看到它们，访问 Nacos 后台<a class="link" href="http://192.168.157.131:8848/nacos">http://192.168.157.131:8848/nacos<i class="fas fa-external-link-alt"></i></a><br>你会看到大量 SEATA_GROUP 分组的配置，这些配置信息在 Seata-Server 启动时都会自动读取。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/10.png" alt="Seata-Server 配置信息" loading="lazy"></p><center>Seata-Server 配置信息</center><h3 id="第四步-创建并初始化-Seata-Server-全局事务数据库。"><a href="#第四步-创建并初始化-Seata-Server-全局事务数据库。" class="headerlink" title="第四步 创建并初始化 Seata-Server 全局事务数据库。"></a>第四步 创建并初始化 Seata-Server 全局事务数据库。</h3><p>访问下面网址</p><p><a class="link" href="https://github.com/seata/seata/blob/1.4.0/script/server/db/mysql.sql%EF%BC%8C%E4%B8%8B%E8%BD%BD">https://github.com/seata/seata/blob/1.4.0/script/server/db/mysql.sql，下载<i class="fas fa-external-link-alt"></i></a> SQL 脚本。在 3309 端口 MySQL 创建新的数据库 seata，执行 SQL 脚本创建全局事务表。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/10.png" alt="Seata 全局事务数据库" loading="lazy"></p><center>Seata 全局事务数据库</center><p>脚本执行后会创建 3 张表，我们了解下即可。</p><ul><li><p>global_table 保存全局事务数据；</p></li><li><p>branch_table 保存分支事务数据；</p></li><li><p>lock_table 保存锁定资源数据。</p></li></ul><h3 id="第五步-启动-seata-server。"><a href="#第五步-启动-seata-server。" class="headerlink" title="第五步 启动 seata-server。"></a>第五步 启动 seata-server。</h3><p>seata-server 启动只需要执行 bin/seata-server.sh。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/seata-server.sh</span><br></pre></td></tr></table></figure><p>启动后，看到下面 Server started 代表启动成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10:52:38.254  INFO --- [                     main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; inited</span><br><span class="line"></span><br><span class="line">10:52:38.501  INFO --- [                     main] i.s.core.rpc.netty.NettyServerBootstrap  : Server started, listen port: 8091</span><br></pre></td></tr></table></figure><p>这里有个细节，如果启动过程中提示数据库无法访问，说明 IP、端口配置有问题，可以通过 Nacos 配置中心设置 store.db.url 选项，而不是重新导入 config.txt。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/11.png" alt="修改 Seata 连接字符串" loading="lazy"></p><center>修改 Seata 连接字符串</center><p>到这里，<strong>阶段二：部署 TC 组件 Seata-Server 已经完成</strong>。后面的事情就是基于 TC 组件 Seata-Server 实现分布式事务。</p><h2 id="开发-RM-资源管理器"><a href="#开发-RM-资源管理器" class="headerlink" title="开发 RM 资源管理器"></a>开发 RM 资源管理器</h2><p>在 Seata 中 RM 资源管理器代表处理具体业务的模块，例如：订单服务创建订单、会员服务增加积分、库存服务减少库存都是 RM 资源管理器，下面我们来开发订单服务、会员服务与库存服务。</p><h3 id="订单服务-rm-order"><a href="#订单服务-rm-order" class="headerlink" title="订单服务 rm-order"></a>订单服务 rm-order</h3><p>这里开发框架采用 Spring Boot + JPA（Hibernate）+ Druid 实现。</p><h3 id="第一步，创建-seata-order-数据库与-undo-log-表。"><a href="#第一步，创建-seata-order-数据库与-undo-log-表。" class="headerlink" title="第一步，创建 seata-order 数据库与 undo_log 表。"></a>第一步，创建 seata-order 数据库与 undo_log 表。</h3><p>在 103 节点的 3306 数据库上，创建 seata-order 数据库，执行下面的 SQL 初始化数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Table structure for order</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">order</span>`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">order</span>`  (</span><br><span class="line"></span><br><span class="line">  `order_id` <span class="type">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `goods_id` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品编号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `member_id` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;会员编号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `quantity` <span class="type">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买数量&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `points` <span class="type">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;增加会员积分&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`order_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line"></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">51</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Table structure for undo_log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `undo_log`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log`  (</span><br><span class="line"></span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"></span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  `log_created` datetime(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  `log_modified` datetime(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `ux_undo_log`(`xid`, `branch_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line"></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">5</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据库包含两张表，一张是订单业务表 order，字段含义已在脚本中注释。而另一张 undo_log 回滚日志表。undo_log 是 Seata 强制要求在每个 RM 端数据库创建的表，用于存储反向 SQL 的元数据。undo_log 表的脚本可以从 Seata GitHub 官方获取，然后在自己的业务库中执行。</p><p><a class="link" href="https://github.com/seata/seata/blob/1.4.0/script/client/at/db/mysql.sql">https://github.com/seata/seata/blob/1.4.0/script/client/at/db/mysql.sql<i class="fas fa-external-link-alt"></i></a></p><p>到这里 RM 数据库创建完毕。</p><p><img src="/2022/06/16/2022-06-16Seata分布式事务实战教程/12.png" alt="seata-order 数据库" loading="lazy"></p><center>seata-order 数据库</center><h3 id="第二步，利用-Spring-Initializr-向导创建-rm-order-工程，确保-pom-xml-引入以下依赖。"><a href="#第二步，利用-Spring-Initializr-向导创建-rm-order-工程，确保-pom-xml-引入以下依赖。" class="headerlink" title="第二步，利用 Spring Initializr 向导创建 rm-order 工程，确保 pom.xml 引入以下依赖。"></a>第二步，利用 Spring Initializr 向导创建 rm-order 工程，确保 pom.xml 引入以下依赖。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring Boot JPA--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Web MVC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Nacos客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata 客户端最新版--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata与spring boot starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--JDBC驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这份依赖有个注意事项，默认 starter-alibaba-seata 依赖内置的是旧版 1.3.0 的 Seata 客户端，因此要排除，在后面引入最新的 1.4.0，保证客户端与 Seate-Server 版本一致。</p><h3 id="第三步，配置-application-yml。"><a href="#第三步，配置-application-yml。" class="headerlink" title="第三步，配置 application.yml。"></a>第三步，配置 application.yml。</h3><p>application.yml 额外配置了事务分组与 Nacos 的信息，我已在配置文件中进行了注释说明。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#seata配置</span></span><br><span class="line"><span class="attr">seata:</span></span><br><span class="line"><span class="comment">#  开启seata分布式事务</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#  事务服务分组名,与naocs一致</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line"><span class="comment">#  是否启用数据源代理</span></span><br><span class="line">  <span class="attr">enable-auto-data-source-proxy:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#  事务服务配置</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line"><span class="comment">#      事务分组对应集群名称</span></span><br><span class="line">      <span class="attr">my_test_tx_group:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">grouplist:</span></span><br><span class="line"><span class="comment">#      Seata-Server服务的IP地址与端口</span></span><br><span class="line">      <span class="attr">default:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.107</span><span class="string">:8091</span></span><br><span class="line">    <span class="attr">enable-degrade:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable-global-transaction:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#    Nacos配置中心信息</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">serverAddr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">default</span></span><br><span class="line"><span class="comment">#      Nacos注册中心信息</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group :</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">default</span></span><br><span class="line"><span class="comment"># 应用配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rm-order</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.31.103:3306/seata-order</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io:</span></span><br><span class="line">      <span class="attr">seata:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="第四步，像单机应用一样开发数据库-CRUD，代码很简单，我已给出注释。"><a href="#第四步，像单机应用一样开发数据库-CRUD，代码很简单，我已给出注释。" class="headerlink" title="第四步，像单机应用一样开发数据库 CRUD，代码很简单，我已给出注释。"></a>第四步，像单机应用一样开发数据库 CRUD，代码很简单，我已给出注释。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JPA实体类</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;`order`&quot;)</span> <span class="comment">//对应order表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id; <span class="comment">//订单编号</span></span><br><span class="line">    <span class="keyword">private</span> Integer memberId; <span class="comment">//会员编号</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;goods_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer goodsId; <span class="comment">//商品编号</span></span><br><span class="line">    <span class="keyword">private</span> Integer points; <span class="comment">//新增积分</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity; <span class="comment">//销售数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(Integer id, Integer memberId, Integer goodsId, Integer points, Integer quantity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.memberId = memberId;</span><br><span class="line">        <span class="keyword">this</span>.points = points;</span><br><span class="line">        <span class="keyword">this</span>.goodsId = goodsId;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderRepository 接口用于声明 CRUD 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Order</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderService 的 createOrder 方法实现创建订单的业务逻辑，注意在 createOrder 方法上必须增加 @Transactional 注解，Seata 客户端对这个注解进行扩展支持了分布式事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">createOrder</span><span class="params">(Integer orderId,Integer memberId,Integer goodsId,Integer points,Integer quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderRepository.save(<span class="keyword">new</span> Order(orderId, memberId,goodsId,points,quantity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderController 的 createOrder 方法用于对外暴露 RESTful API，等待被 TM 调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/create_order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createOrder</span><span class="params">(Integer orderId,Integer memberId,Integer goodsId,Integer points,Integer quantity)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        Map result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Order order = orderService.createOrder(orderId,memberId,goodsId,points,quantity);</span><br><span class="line">        result.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        result.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;create order success&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjectMapper().writeValueAsString(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五步，让-Seata-客户端在处理事务时自动生成反向-SQL"><a href="#第五步，让-Seata-客户端在处理事务时自动生成反向-SQL" class="headerlink" title="第五步，让 Seata 客户端在处理事务时自动生成反向 SQL"></a>第五步，让 Seata 客户端在处理事务时自动生成反向 SQL</h3><p>最重要的一步，要让 Seata 客户端在处理事务时自动生成反向 SQL，必须额外配置 DataSourceProxy 数据源代理类，DataSourceProxy 是 Seata 提供的 DataSource 代理类，在分布式事务执行过程中，用于自动生成 undo_log 回滚数据，以及自动完成 RM 端分布式事务的提交或回滚操作。</p><p>在 Spring Boot 中利用 Java Config 方式对 DataSourceProxy 进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lagou.rmorder.datasource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProxyConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Druid数据源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立DataSource数据源代理</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProxy <span class="title">dataSource</span><span class="params">(DruidDataSource druidDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，启动 rm-order，在浏览器地址栏访问 create_order 接口，看到 create order success，在数据库中也出现对应记录。<br><a class="link" href="http://192.168.31.106:8002/create_order?orderId=6&amp;memberId=1&amp;goodsId=2&amp;points=20&amp;quantity=200">http://192.168.31.106:8002/create_order?orderId=6&amp;memberId=1&amp;goodsId=2&amp;points=20&amp;quantity=200<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    message: <span class="string">&quot;create order success&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;综合应用：Seata-分布式事务实战教程&quot;&gt;&lt;a href=&quot;#综合应用：Seata-分布式事务实战教程&quot; class=&quot;headerlink&quot; title=&quot;综合应用：Seata 分布式事务实战教程&quot;&gt;&lt;/a&gt;综合应用：Seata 分布式事务实战教程&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="java | 微服务 seata" scheme="categories/java-微服务-seata/"/>
    
    
    <category term="java,微服务,nacos seata" scheme="tags/java-微服务-nacos-seata/"/>
    
  </entry>
  
  <entry>
    <title>基于RocketMQ实现服务异步通信</title>
    <link href="2022/06/13/2022-06-13%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    <id>2022/06/13/2022-06-13%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2022-06-13T06:50:00.000Z</published>
    <updated>2022-06-16T15:15:26.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息队列：基于-RocketMQ-实现服务异步通信"><a href="#消息队列：基于-RocketMQ-实现服务异步通信" class="headerlink" title="消息队列：基于 RocketMQ 实现服务异步通信"></a>消息队列：基于 RocketMQ 实现服务异步通信</h1><h2 id="消息队列-与-RocketMQ"><a href="#消息队列-与-RocketMQ" class="headerlink" title="消息队列 与 RocketMQ"></a>消息队列 与 RocketMQ</h2><h3 id="消息队列-MQ"><a href="#消息队列-MQ" class="headerlink" title="消息队列 MQ"></a>消息队列 MQ</h3><p>消息队列（Message Queue）简称 MQ，是一种跨进程的通信机制，通常用于应用程序间进行数据的异步传输，MQ 产品在架构中通常也被叫作“消息中间件”。它的最主要职责就是<strong>保证服务间进行可靠的数据传输，同时实现服务间的解耦</strong>。</p><p>这么说太过学术，我们看一个项目的实际案例，假设市级税务系统向省级税务系统上报本年度税务汇总数据，按以往的设计市级税务系统作为数据的生产者需要了解省级税务系统的 IP、端口、接口等诸多细节，然后通过 RPC、RESTful 等方式同步向省级税务系统发送数据，省级税务系统作为数据的消费者接受后响应“数据已接收”。</p><p><img src="/2022/06/13/2022-06-13基于RocketMQ实现服务异步通信/1.png" alt="系统间跨进程通信" loading="lazy"></p><center>系统间跨进程通信</center><p>虽然从逻辑上是没有问题的，但是从技术层面却衍生出三个新问题：</p><ul><li><p>假如上报时省级税务系统正在升级维护，市级税务系统就必须设计额外的重发机制保证数据的完整性；</p></li><li><p>假如省级税务系统接收数据需要 1 分钟处理时间，市级税务系统采用同步通信，则市级税务系统传输线程就要阻塞 1 分钟，在高并发场景下如此长时间的阻塞很容易造成系统的崩溃；</p></li><li><p>假如省级税务系统接口的调用方式、接口、IP、端口有任何改变，都必须立即通知市级税务系统进行调整，否则就会出现通信失败。</p></li></ul><p>从以上三个问题可以看出，省级系统产生的变化直接影响到市级税务系统的执行，两者产生了强耦合，如果问题放在互联网的微服务架构中，几十个服务进行串联调用，每个服务间如果都产生类似的强耦合，系统必然难以维护。</p><p>为了解决这种情况，我们需要在架构中部署消息中间件，这个组件应提供可靠的、稳定的、与业务无关的特性，使进程间通信解耦，而这一类消息中间件的代表产品就是 MQ 消息队列。当引入 MQ 消息队列后，消息传递过程会产生以下变化。</p><p><img src="/2022/06/13/2022-06-13基于RocketMQ实现服务异步通信/2.png" alt="引入 MQ 后通信过程" loading="lazy"></p><center>引入 MQ 后通信过程</center><p>可以看到，引入消息队列后，生产者与消费者都只面向消息队列进行数据处理，数据生产者根本不需要了解具体消费者的信息，只要把数据按事先约定放在指定的队列中即可。而消费者也是一样的，消费者端监听消息队列，如果队列中产生新的数据，MQ 就会通过“推送 PUSH”或者“抽取 PULL”的方式让消费者获取到新数据进行后续处理。</p><p>通过示意图可以看到，只要消息队列产品是稳定可靠的，那消息通信的过程就是有保障的。在架构领域，很多厂商都开发了自己的 MQ 产品，最具代表性的开源产品有：</p><p><img src="/2022/06/13/2022-06-13基于RocketMQ实现服务异步通信/7.png" alt="具代表性的MQ产品" loading="lazy"></p><center>具代表性的MQ产品</center><p>每一种产品都有自己不同的设计与实现原理，但根本的目标都是相同的：为进程间通信提供可靠的异步传输机制。RocketMQ 作为阿里系产品天然被整合进 Spring Cloud Alibaba 生态，在经历过多次双 11 的考验后，RocketMQ 在性能、可靠性、易用性方面都是非常优秀的，下面咱们来了解下 RocketMQ 吧。</p><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ 是一款分布式消息队列中间件，官方地址为<a class="link" href="http://rocketmq.apache.org/">http://rocketmq.apache.org/<i class="fas fa-external-link-alt"></i></a> ，目前最新版本为4.9.3。RocketMQ 最初设计是为了满足阿里巴巴自身业务对异步消息传递的需要，在 3.X 版本后正式开源并捐献给 Apache，目前已孵化为 Apache 顶级项目，同时也是国内使用最广泛、使用人数最多的 MQ 产品之一。</p><p>RocketMQ 有很多优秀的特性，在可用性方面，RocketMQ 强调集群无单点，任意一点高可用，客户端具备负载均衡能力，可以轻松实现水平扩容；在性能方面，在天猫双 11 大促背后的亿级消息处理就是通过 RocketMQ 提供的保障；在 API 方面，提供了丰富的功能，可以实现异步消息、同步消息、顺序消息、事务消息等丰富的功能，能满足大多数应用场景；在可靠性方面，提供了消息持久化、失败重试机制、消息查询追溯的功能，进一步为可靠性提供保障。</p><p><img src="/2022/06/13/2022-06-13基于RocketMQ实现服务异步通信/8.png" alt="RocketMQ特性" loading="lazy"></p><center>RocketMQ特性</center><p>了解 RocketMQ 的诸多特性后，咱们来理解 RocketMQ 几个重要的概念：</p><ul><li><p>消息 Message：消息在广义上就是进程间传递的业务数据，在狭义上不同的 MQ 产品对消息又附加了额外属性如：Topic（主题）、Tags（标签）等；</p></li><li><p>消息生产者 Producer：指代负责生产数据的角色，在前面案例中市级税务系统就充当了消息生产者的角色；</p></li><li><p>消息消费者 Consumer：指代使用数据的角色，前面案例的省级税务系统就是消息消费者；</p></li><li><p>MQ消息服务 Broker：MQ 消息服务器的统称，用于消息存储与消息转发；</p></li><li><p>生产者组 Producer Group：对于发送同一类消息的生产者，RocketMQ 对其分组，成为生产者组；</p></li><li><p>消费者组 Consumer Group：对于消费同一类消息的消费者，RocketMQ 对其分组，成为消费者组。</p></li></ul><p><img src="/2022/06/13/2022-06-13基于RocketMQ实现服务异步通信/3.png" alt="RocketMQ 组成示意图" loading="lazy"></p><center>RocketMQ 组成示意图</center><p>在理解这些基本概念后，咱们正式进入 RocketMQ 的部署与使用环节，通过案例代码理解 RocketMQ 的执行过程。对于 RocketMQ 来说，使用它需要两个阶段：搭建 RocketMQ 服务器集群与应用接入 RocketMQ 队列，首先咱们来部署 RocketMQ 集群。</p><h2 id="部署-RocketMQ-集群"><a href="#部署-RocketMQ-集群" class="headerlink" title="部署 RocketMQ 集群"></a>部署 RocketMQ 集群</h2><p>RocketMQ 天然采用集群模式，常见的 RocketMQ 集群有三种形式：<strong>多 Master 模式</strong>、<strong>多 Master 多 Slave- 异步复制模式</strong>、<strong>多 Master 多 Slave- 同步双写模式</strong>，这三种模式各自的优缺点如下。</p><ul><li><p><strong>多 Master 模式是配置最简单的模式</strong>，同时也是使用最多的形式。优点是单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，同步刷盘消息也不会丢失，性能也是最高的；缺点是单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</p></li><li><p><strong>多 Master 多 Slave 异步复制模式</strong>。每个 Master 配置一个 Slave，有多对 Master-Slave，HA 采用异步复制方式，主备有短暂消息毫秒级延迟，即使磁盘损坏只会丢失少量消息，且消息实时性不会受影响。同时 Master 宕机后，消费者仍然可以从 Slave 消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样；缺点是 Master 宕机，磁盘损坏情况下会丢失少量消息。</p></li><li><p><strong>多 Master 多 Slave 同步双写模式</strong>，HA 采用同步双写方式，即只有主备都写成功，才向应用返回成功，该模式数据与服务都无单点故障，Master 宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；缺点是性能比异步复制模式低 10% 左右，发送单个消息的执行时间会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</p></li></ul><p>本讲我们将搭建一个双 Master 服务器集群，首先来看一下部署架构图：</p><p><img src="/2022/06/13/2022-06-13基于RocketMQ实现服务异步通信/4.png" alt="双 Master 架构图" loading="lazy"></p><center>双 Master 架构图</center><p>在双 Master 架构中，出现了一个新角色 NameServer（命名服务器），NameServer 是 RocketMQ 自带的轻量级路由注册中心，支持 Broker 的动态注册与发现。在 Broker 启动后会自动向 NameServer 发送心跳包，通知 Broker 上线。当 Provider 向 NameServer 获取路由信息，然后向指定 Broker 建立长连接完成数据发送。</p><p>为了避免单节点瓶颈，通常 NameServer 会部署两台以上作为高可用冗余。NameServer 本身是无状态的，各实例间不进行通信，因此在 Broker 集群配置时要配置所有 NameServer 节点以保证状态同步。</p><p>部署 RocketMQ 集群要分两步：部署 NameServer 与部署 Broker 集群。</p><h3 id="第一步，部署-NameServer-集群。"><a href="#第一步，部署-NameServer-集群。" class="headerlink" title="第一步，部署 NameServer 集群。"></a>第一步，部署 NameServer 集群。</h3><p>我们创建两台 CentOS7 虚拟机，IP 地址分别为 192.168.157.130 与 192.168.157.133，要求这两台虚拟机内存大于 2G，并安装好 64 位 JDK1.8，具体过程不再演示。</p><p>之后访问 Apache RocketMQ 下载页：</p><p><a class="link" href="https://dlcdn.apache.org/rocketmq/4.9.3/rocketmq-all-4.9.3-bin-release.zip">https://dlcdn.apache.org/rocketmq/4.9.3/rocketmq-all-4.9.3-bin-release.zip<i class="fas fa-external-link-alt"></i></a></p><p>获取 RocketMQ 最新版 rocketmq-all-4.9.3-bin-release.zip，解压后编辑 rocketmq-4.9.3/bin/runserver.sh 文件，因为 RocketMQ 是服务器软件，默认为其配置 4G 内存，这是 PC 机及或者笔记本吃不消的，所以在 71 行附近将 JVM 内存缩小到 1GB 以方便演示。</p><p>修改前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure><p>修改完毕，将 rocketmq-all-4.8.0-bin-release 上传到两台 NameServer 虚拟机的 /usr/local 目录下，执行 bin 目录下的 mqnamesrv 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq-4.9.3/bin/</span><br><span class="line">sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure><p>mqnamesrv 是 RocketMQ 自带 NameServer 的启动命令，执行后看到 The Name Server boot success. serializeType=JSON 就代表 NameServer 启动成功，NameServer 将占用 9876 端口提供服务，不要忘记在防火墙设置放行。之后如法炮制在另一台 133 设备上部署 NameServer，构成 NameServer 集群。</p><h3 id="部署-Broker-集群。"><a href="#部署-Broker-集群。" class="headerlink" title="部署 Broker 集群。"></a>部署 Broker 集群。</h3><p>我们再额外创建两台 CentOS7 虚拟机，IP 地址分别为 192.168.157.130 与 192.168.157.133，同样要求这两台虚拟机内存大于 2G，并安装好 64 位 JDK1.8。</p><p>打开 rocketmq-all-4.8.0-bin-release 目录，编辑 /bin/runbroker.sh 文件，同样将启动 Broker 默认占用内存从 8G 缩小到 1G，将 85 行调整为以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g&quot;</span><br></pre></td></tr></table></figure><p>在 conf 目录下，RocketMQ 已经给我们贴心的准备好三组集群配置模板：</p><ul><li><p>2m-2s-async 代表双主双从异步复制模式；</p></li><li><p>2m-2s-sync 代表双主双从同步双写模式；</p></li><li><p>2m-noslave 代表双主模式。</p></li></ul><p>我们在 2m-noslave 双主模式目录中，在 broker-a.properties 与 broker-b.properties 末尾追加 NameServer 集群的地址，为了方便理解我也将模板里面每一项的含义进行注释，首先是 broker-a.properties 的完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#集群名称，同一个集群下的 broker 要求统一</span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">#broker 名称</span><br><span class="line">brokerName=broker-a</span><br><span class="line">#brokerId=0 代表主节点，大于零代表从节点</span><br><span class="line">brokerId=0</span><br><span class="line">#删除日志文件时间点，默认凌晨 4 点</span><br><span class="line">deleteWhen=04</span><br><span class="line">#日志文件保留时间，默认 48 小时</span><br><span class="line">fileReservedTime=48</span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘，性能好宕机会丢数</span><br><span class="line">#- SYNC_FLUSH 同步刷盘，性能较差不会丢数</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">#末尾追加，NameServer 节点列表，使用分号分割</span><br><span class="line">namesrvAddr=192.168.157.130:9876;192.168.157.133:9876</span><br></pre></td></tr></table></figure><p>broker-b.properties 只有 brokerName 不同，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-b</span><br><span class="line">brokerId=0</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">#末尾追加，NameServer 节点列表，使用分号分割</span><br><span class="line">namesrvAddr=192.168.157.130:9876;192.168.157.133:9876</span><br></pre></td></tr></table></figure><p>之后将 rocketmq-all-4.8.0-bin-release 目录上传到 /usr/local 目录，运行下面命令启动 broker 节点 a。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq-all-4.8.0-bin-release/</span><br><span class="line">sh bin/mqbroker -c ./conf/2m-noslave/broker-a.properties</span><br></pre></td></tr></table></figure><p>在 mqbroker 启动命令后增加 c 参数说明要加载哪个 Broker 配置文件。</p><p>启动成功会看到下面的日志，Broker 将占用 10911 端口提供服务，请设置防火墙放行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The broker[broker-b, 192.168.157.135:10911] boot success. serializeType=JSON and name server is 192.168.157.130:9876;192.168.157.133:9876</span><br></pre></td></tr></table></figure><p>同样的，在另一台 Master 执行下面命令，启动并加载 broker-b 配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq-all-4.8.0-bin-release/</span><br><span class="line">sh bin/mqbroker -c ./conf/2m-noslave/broker-b.properties</span><br></pre></td></tr></table></figure><p>到这里 NameServer 集群与 Broker 集群就部署好了，下面执行两个命令验证下。</p><p>第一个，使用 mqadmin 命令查看集群状态。</p><p>在 bin 目录下存在 mqadmin 命令用于管理 RocketMQ 集群，我们可以使用 clusterList 查看集群节点，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh mqadmin clusterList -n 192.168.31.200:9876</span><br></pre></td></tr></table></figure><p>通过查询 NameServer 上的注册信息，得到以下结果。</p><p><img src="/2022/06/13/2022-06-13基于RocketMQ实现服务异步通信/5.png" alt="Broker 集群信息" loading="lazy"></p><center>Broker 集群信息</center><p>可以看到在 DefaultCluster 集群中存在两个 Broker，因为 BID 编号为 0，代表它们都是 Master 主节点。</p><p>第二个，利用 RocketMQ 自带的 tools.sh 工具通过生成演示数据来测试 MQ 实际的运行情况。在 bin 目录下使用下面命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NAMESRV_ADDR=192.168.157.130:9876</span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure><p>你会看到屏幕输出日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SendResult [sendStatus=SEND_OK, msgId=7F0000010B664DC639969F28CF540000, offsetMsgId=C0A81FD200002A9F00000000000413B6, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=1], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=7F0000010B664DC639969F28CF9B0001, offsetMsgId=C0A81FD200002A9F000000000004147F, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=2], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=7F0000010B664DC639969F28CFA30002, offsetMsgId=C0A81FD200002A9F0000000000041548, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=3], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=7F0000010B664DC639969F28CFA70003, offsetMsgId=C0A81FD300002A9F0000000000033C56, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-b, queueId=0], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=7F0000010B664DC639969F28CFD60004, offsetMsgId=C0A81FD300002A9F0000000000033D1F, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-b, queueId=1], queueOffset=0]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=7F0000010B664DC639969F28CFDB0005, offsetMsgId=C0A81FD300002A9F0000000000033DE8, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-b, queueId=2], queueOffset=0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中broker-a、broker-b 交替出现说明集群生效了。</p><p>前面测试的是服务提供者，下面测试消费者，运行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NAMESRV_ADDR=192.168.157.130:9876</span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p>会看到消费者也获取到数据，到这里 RocketMQ 双 Master 集群的搭建就完成了，至于多 Master 多 Slave 的配置也是相似的，大家查阅官方文档相信也能很快上手。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConsumeMessageThread_11 Receive New Messages: [MessageExt [brokerName=broker-b, queueId=2, storeSize=203, queueOffset=157, sysFlag=0, bornTimestamp=1612100880154, bornHost=/192.168.31.210:54104, storeTimestamp=1612100880159, storeHost=/192.168.31.211:10911, msgId=C0A81FD300002A9F0000000000053509, commitLogOffset=341257, bodyCRC=1116443590, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=158, CONSUME_START_TIME=1612100880161, UNIQ_KEY=7F0000010DA64DC639969F2C4B1A0314, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 55, 56, 56], transactionId=&#x27;null&#x27;&#125;]] </span><br><span class="line"></span><br><span class="line">ConsumeMessageThread_12 Receive New Messages: [MessageExt [brokerName=broker-b, queueId=3, storeSize=203, queueOffset=157, sysFlag=0, bornTimestamp=1612100880161, bornHost=/192.168.31.210:54104, storeTimestamp=1612100880162, storeHost=/192.168.31.211:10911, msgId=C0A81FD300002A9F00000000000535D4, commitLogOffset=341460, bodyCRC=898409296, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=158, CONSUME_START_TIME=1612100880164, UNIQ_KEY=7F0000010DA64DC639969F2C4B210315, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 55, 56, 57], transactionId=&#x27;null&#x27;&#125;]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="应用接入-RocketMQ-集群"><a href="#应用接入-RocketMQ-集群" class="headerlink" title="应用接入 RocketMQ 集群"></a>应用接入 RocketMQ 集群</h3><p><img src="/2022/06/13/2022-06-13基于RocketMQ实现服务异步通信/6.png" alt="案例说明" loading="lazy"></p><center>案例说明</center><p>我们以前面的报税为例，利用 Spring Boot 集成 MQ 客户端实现消息收发，首先咱们模拟生产者 Producer。</p><h4 id="生产者-Producer-发送消息"><a href="#生产者-Producer-发送消息" class="headerlink" title="生产者 Producer 发送消息"></a>生产者 Producer 发送消息</h4><p>第一步，利用 Spring Initializr 向导创建 rocketmq-Producer 工程，确保 pom.xml 引入以下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- RocketMQ客户端，版本与Broker保持一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，配置应用 application.yml。</p><p>rocketmq-client 主要通过编码实现通信，因此无须在 application.yml 做额外配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rocketmq-producer</span></span><br></pre></td></tr></table></figure><p>第三步，创建 Controller，生产者发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(ProducerController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/send_s1_tax&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send1</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">//创建DefaultMQProducer消息生产者对象</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;producer-group&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer节点地址，多个节点间用分号分割</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.157.130:9876;192.168.157.133:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//与NameServer建立长连接</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发送一百条数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line">                <span class="comment">//数据正文</span></span><br><span class="line">                String data = <span class="string">&quot;&#123;\&quot;title\&quot;:\&quot;X市2022年度第一季度税务汇总数据\&quot;&#125;&quot;</span>;</span><br><span class="line">                <span class="comment">/*创建消息</span></span><br><span class="line"><span class="comment">                    Message消息三个参数</span></span><br><span class="line"><span class="comment">                    topic 代表消息主题，自定义为tax-data-topic说明是税务数据</span></span><br><span class="line"><span class="comment">                    tags 代表标志，用于消费者接收数据时进行数据筛选。2021S1代表2021年第一季度数据</span></span><br><span class="line"><span class="comment">                    body 代表消息内容</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                Message message = <span class="keyword">new</span> Message(<span class="string">&quot;tax-data-topic&quot;</span>, <span class="string">&quot;2021S1&quot;</span>, data.getBytes());</span><br><span class="line">                <span class="comment">//发送消息，获取发送结果</span></span><br><span class="line">                SendResult result = producer.send(message);</span><br><span class="line">                <span class="comment">//将发送结果对象打印在控制台</span></span><br><span class="line">                logger.info(<span class="string">&quot;消息已发送：MsgId:&quot;</span> + result.getMsgId() + <span class="string">&quot;，发送状态:&quot;</span> + result.getSendStatus());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序运行后，访问<a class="link" href="http://localhost:8000/send_s1_tax%EF%BC%8C%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E8%BE%93%E5%87%BA%E8%AF%B4%E6%98%8E%E6%95%B0%E6%8D%AE%E5%B7%B2%E8%A2%AB">http://localhost:8000/send_s1_tax，在控制台会看到如下输出说明数据已被<i class="fas fa-external-link-alt"></i></a> Broker 接收，Broker 接收后 Producer 端任务已完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: 消息已发送：MsgId:7F000001438018B4AAC2523C92770000，发送状态:SEND_OK</span><br><span class="line">: 消息已发送：MsgId:7F000001438018B4AAC2523C929F0001，发送状态:SEND_OK</span><br></pre></td></tr></table></figure><p>下面咱们开发消费者 Consumer。</p><h4 id="消费者-Consumer-接收消息"><a href="#消费者-Consumer-接收消息" class="headerlink" title="消费者 Consumer 接收消息"></a>消费者 Consumer 接收消息</h4><p>第一步，利用 Spring Initializr 向导创建 rocketmq-consumer 工程，确保 pom.xml 引入以下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- RocketMQ客户端，版本与Broker保持一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，application.yml 同样无须做额外设置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rocketmq-consumer</span></span><br></pre></td></tr></table></figure><p>第三步，在应用启动入口 RocketmqConsumerApplication 增加消费者监听代码，关键的代码都已做好注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketmqConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RocketmqConsumerApplication.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        SpringApplication.run(RocketmqConsumerApplication.class, args);</span><br><span class="line">        <span class="comment">//创建消费者对象</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">        <span class="comment">//设置NameServer节点</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.157.130:9876;192.168.157.133:9876&quot;</span>);</span><br><span class="line">        <span class="comment">/*订阅主题，</span></span><br><span class="line"><span class="comment">        consumer.subscribe包含两个参数：</span></span><br><span class="line"><span class="comment">        topic: 说明消费者从Broker订阅哪一个主题，这一项要与Provider保持一致。</span></span><br><span class="line"><span class="comment">        subExpression: 子表达式用于筛选tags。</span></span><br><span class="line"><span class="comment">            同一个主题下可以包含很多不同的tags，subExpression用于筛选符合条件的tags进行接收。</span></span><br><span class="line"><span class="comment">            例如：设置为*，则代表接收所有tags数据。</span></span><br><span class="line"><span class="comment">            例如：设置为2020S1，则Broker中只有tags=2020S1的消息会被接收，而2020S2就会被排除在外。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;tax-data-topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//创建监听，当有新的消息监听程序会及时捕捉并加以处理。</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                    List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//批量数据处理</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;消费者消费数据:&quot;</span>+<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//返回数据已接收标识</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动消费者，与Broker建立长连接，开始监听。</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用启动后，Provider 产生新消息的同时，Consumer 端就会立即消费掉，控制台产生输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2021-01-31 22:25:14.212  INFO 17328 --- [MessageThread_3] c.l.r.RocketmqConsumerApplication        : 消费者消费数据:&#123;&quot;title&quot;:&quot;X市2021年度第一季度税务汇总数据&quot;&#125;</span><br><span class="line"></span><br><span class="line">2021-01-31 22:25:14.217  INFO 17328 --- [MessageThread_2] c.l.r.RocketmqConsumerApplication        : 消费者消费数据:&#123;&quot;title&quot;:&quot;X市2021年度第一季度税务汇总数据&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上便是 Spring Boot 接入 RocketMQ 集群的过程。对于当前的案例我们是通过代码方式控制消息收发，在 Spring Cloud 生态中还提供了 Spring Cloud Stream 模块，允许程序员采用“声明式”的开发方式实现与 MQ 更轻松的接入，但 Spring Cloud Stream 本身封装度太高，很多 RocketMQ 的细节也被隐藏了，这对于入门来说并不是一件好事。在掌握 RocketMQ 的相关内容后再去学习 Spring Cloud Stream 你会理解得更加透彻。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息队列：基于-RocketMQ-实现服务异步通信&quot;&gt;&lt;a href=&quot;#消息队列：基于-RocketMQ-实现服务异步通信&quot; class=&quot;headerlink&quot; title=&quot;消息队列：基于 RocketMQ 实现服务异步通信&quot;&gt;&lt;/a&gt;消息队列：基于 Roc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AlibabaSeata如何实现分布式事务</title>
    <link href="2022/06/12/2022-06-12AlibabaSeata%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>2022/06/12/2022-06-12AlibabaSeata%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-06-12T14:02:29.000Z</published>
    <updated>2022-06-14T14:01:24.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务：Alibaba-Seata-如何实现分布式事务"><a href="#分布式事务：Alibaba-Seata-如何实现分布式事务" class="headerlink" title="分布式事务：Alibaba Seata 如何实现分布式事务"></a>分布式事务：Alibaba Seata 如何实现分布式事务</h1><h2 id="分布式事务的解决方案"><a href="#分布式事务的解决方案" class="headerlink" title="分布式事务的解决方案"></a>分布式事务的解决方案</h2><p>下面咱们先聊一下为什么会产生分布式事务。咱们举个例子，某线上商城会员在购买商品的同时产生相应的消费积分，消费积分在下一次购物时可以抵用现金。这个业务的逻辑如果放在以前的单点应用是很简单的，如下所示。</p><blockquote><p>开启数据库事务<br>创建订单<br>会员积分增加<br>商品库存减少<br>提交数据库事务</p></blockquote><p>在这个过程中，因为程序操作的是单点数据库，所以在一个数据库事务中便可完成所有操作，利用数据库事务自带的原子性保证了所有数据要么全部处理成功，要么全部回滚撤销。但是放在以微服务为代表的分布式架构下问题就没那么简单了，我们来看一下示意图。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/1.png" alt="分布式架构下调用关系图" loading="lazy"></p><center>分布式架构下调用关系图</center><p>可以看到，商城应用作为业务的发起者分别向订单、会员、库存服务发起了调用，而这些服务又拥有自己独立的数据存储，因为在物理上各个数据库服务器都是独立的，每一个步骤的操作都会创建独立的事务，这就意味着在分布式处理时无法通过单点数据库利用一个事务保证数据的完整性，我们必须引入某种额外的机制来协调多个事务要么全部提交、要么全部回滚，以此保证数据的完整性，这便是“分布式事务”的由来。</p><p>在分布式架构中有两种经典的分布式事务解决方案：<strong>二阶段提交（2PC）</strong>与<strong>三阶段提交（3PC）</strong>。</p><h3 id="二阶段提交（2PC）"><a href="#二阶段提交（2PC）" class="headerlink" title="二阶段提交（2PC）"></a>二阶段提交（2PC）</h3><p>首先咱们分析下二阶段提交的处理过程，下面是二阶段提交中的<strong>第一个阶段：事务预处理阶段</strong>。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/2.png" alt="2PC 阶段一：事务预处理阶段" loading="lazy"></p><center>2PC 阶段一：事务预处理阶段</center><p>可以看到，相比单点事务，分布式事务中增加了一个新的角色：事务协调者（Coordinator），它的职责就是协调各个分支事务的开启与提交、回滚的处理。以上图为例，当商城应用订单创建后，首先事务协调者会向各服务下达“处理本地事务”的通知，所谓本地事务就是每个服务应该做的事情，如订单服务中负责创建新的订单记录；会员服务负责增加会员的积分；库存服务负责减少库存数量。在这个阶段，被操作的所有数据都处于未提交（uncommit）的状态，会被排它锁锁定。当本地事务都处理完成后，会通知事务协调者“本地事务处理完毕”。当事务协调者陆续收到订单、会员、库存服务的处理完毕通知后，便进入“<strong>阶段二：提交阶段</strong>”。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/3.png" alt="2PC 阶段二：提交阶段" loading="lazy"></p><center>2PC 阶段二：提交阶段</center><p>在提交阶段，事务协调者会向每一个服务下达提交命令，每个服务收到提交命令后在本地事务中对阶段一未提交的数据执行 Commit 提交以完成数据最终的写入，之后服务便向事务协调者上报“提交成功”的通知。当事务协调者收到所有服务“提交成功”的通知后，就意味着一次分布式事务处理已完成。</p><p>这便是二阶段提交的正常执行过程，但假设在阶段一有任何一个服务因某种原因向事务协调者上报“事务处理失败”，就意味着整体业务处理出现问题，阶段二的操作就自动改为回滚（Rollback）处理，将所有未提交的数据撤销，使数据还原以保证完整性。</p><p>对于二阶段提交来说，它有一个致命问题，当阶段二某个服务因为网络原因无法收到协调者下达的提交命令，则未提交的数据就会被长时间阻塞，可能导致系统崩溃。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/4.png" alt="二阶段提交的缺陷" loading="lazy"></p><center>二阶段提交的缺陷</center><p>以上图为例，假如在提交阶段，库存服务实例与事务协调者之间断网。提交指令无法下达，这会导致库存中的“飞科剃须刀”商品库存记录会长期处于未提交的状态，因为这条记录被数据库排他锁长期独占，之后再有其他线程要访问“飞科剃须刀”库存数据，该线程就会长期处于阻塞状态，随着阻塞线程的不断增加，库存服务会面临崩溃的风险。</p><p>那这个问题要怎么解决呢？其实只要在服务这一侧增加超时机制，过一段时间被锁定的“飞科剃须刀”数据因超时自动执行提交操作，释放锁定资源。尽管这样做会导致数据不一致，但也比线程积压导致服务崩溃要好，出于此目的，三阶段提交（3PC）便应运而生。</p><h3 id="三阶段提交（3PC）"><a href="#三阶段提交（3PC）" class="headerlink" title="三阶段提交（3PC）"></a>三阶段提交（3PC）</h3><p>三阶段提交实质是将二阶段中的提交阶段拆分为“<strong>预提交阶段</strong>”与“<strong>提交阶段</strong>”，同时在服务端都引入超时机制，保证数据库资源不会被长时间锁定。下面是三阶段提交的示意流程：</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/5.png" alt="3PC 阶段一：事务预处理阶段" loading="lazy"></p><center>3PC 阶段一：事务预处理阶段</center><h4 id="阶段一：事务预处理阶段。"><a href="#阶段一：事务预处理阶段。" class="headerlink" title="阶段一：事务预处理阶段。"></a>阶段一：事务预处理阶段。</h4><p>3PC 的事务预处理阶段与 2PC 是一样的，用于处理本地事务，锁定数据库资源，当所有服务返回成功后，进入阶段二。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/6.png" alt="3PC 阶段二：预提交阶段" loading="lazy"></p><center>3PC 阶段二：预提交阶段</center><h4 id="阶段二：预提交阶段。"><a href="#阶段二：预提交阶段。" class="headerlink" title="阶段二：预提交阶段。"></a>阶段二：预提交阶段。</h4><p>预提交阶段只是一个询问机制，以确认所有服务都已准备好，同时在此阶段协调者和参与者都设置了超时时间以防止出现长时间资源锁定。当阶段二所有服务返回“可以提交”，进入阶段三“提交阶段”。</p><h4 id="阶段三：提交阶段。"><a href="#阶段三：提交阶段。" class="headerlink" title="阶段三：提交阶段。"></a>阶段三：提交阶段。</h4><p>3PC 的提交阶段与 2PC 的提交阶段是一致的，在每一个数据库中执行提交实现数据的资源写入，如果协调者与服务通信中断导致无法提交，在服务端超时后在也会自动执行提交操作来保证资源释放。</p><p>通过对比我们发现，三阶段提交是二阶段提交的优化版本，主要通过加入预提交阶段引入了超时机制，让数据库资源不会被长期锁定，但这也会带来一个新问题，数据一致性也很可能因为超时后的强制提交被破坏，对于这个问题各大软件公司都在各显神通，常见的做法有：增加异步的数据补偿任务、日终跑批前的数据补偿、更完善的业务数据完整性的校验代码、引入数据监控及时通知人工补录这些都是不错的补救措施。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/11.png" alt="数据破坏的解决方案" loading="lazy"></p><center>数据破坏的解决方案</center><p>讲到这，相比你对 2PC 与 3PC 的分布式事务方案应该有了初步的了解，这里我还是要强调下，无论是 2PC 与 3PC 都是一种方案，是一种宏观的设计。如果要落地就要依托具体的软件产品，在 Java 开源领域能够提供完善的分布式事务解决方案的产品并不多，比较有代表性的产品有 ByteTCC、TX-LCN、EasyTransaction、Alibaba Seata，其中无论从成熟度、厂商背景、更新频度、社区活跃度各维度比较，Alibaba Seata都是数一数二的分布式事务中间件产品，本讲后面的内容将围绕Alibaba Seata的AT模式展开，探讨Alibaba Seata是如何实现自动化的分布式事务处理的。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/12.png" alt="分布式事务中间件" loading="lazy"></p><center>分布式事务中间件</center><h2 id="Alibaba-Seata-分布式事务中间件"><a href="#Alibaba-Seata-分布式事务中间件" class="headerlink" title="Alibaba Seata 分布式事务中间件"></a>Alibaba Seata 分布式事务中间件</h2><p>Alibaba Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。它的官网是<a class="link" href="http://seata.io/">http://seata.io/<i class="fas fa-external-link-alt"></i></a> ,截止到目前 Seata 在 GitHub 已有 22280 star，最新版本已迭代到 1.5.1，阿里多年的技术沉淀让 Seata 的内部版本平稳渡过了多次双 11 的考验。2019 年 1 月为了打造更加完善的技术生态和普惠技术成果，Seata 正式宣布对外开源，未来 Seata 将以社区共建的形式帮助其技术更加可靠与完备，按官方的说法Seata目前已具备了在生产环境使用的条件。</p><p>Seata 提供了多种分布式事务的解决方案，包含 AT 模式、TCC 模式、SAGA 模式以及 XA 模式。其中 AT 模式提供了最简单易用且无侵入的事务处理机制，通过自动生成反向 SQL 实现事务回滚。从 AT 模式入手使用，使我们理解分布式事务处理机制是非常好的学习办法。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/7.png" alt="Seata 的特色功能" loading="lazy"></p><center>Seata 的特色功能</center><p>AT 模式是 Seata 独创的模式，它是基于 2PC 的方案，核心理念是利用数据库 JDBC 加上 Oracle、MySQL 自带的事务方式来对我们分布式事务进行管理。说起来有点晦涩，下边我就结合这张 AT 模式方案图给大家介绍，在 Seata 中关于分布式事务到底需要哪些组件，以及他们都起到了什么样的职能。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/8.png" alt="Seata 组件图" loading="lazy"></p><center>Seata 组件图</center><p>通过Seata组件图我们可以看到三个组成部分：</p><ul><li><p><strong>第一个是事务协调者（TC）</strong>，它的作用是维护全局和分支事务的状态，驱动全局事务提交或者回滚，这正是前面讲解 2PC 或者 3PC 方案时提到的事务协调者组件的具体实现，TC 由 SEATA 官方提供。</p></li><li><p><strong>第二个是事务管理器（TM）</strong>，事务管理器用于定义全局事务的范围，开始全局事务提交或者回滚全局事务都是由 TM 来决定。</p></li><li><p><strong>第三个是资源管理器（RM）</strong>，他用于管理分支事务处理的资源，并且报告分支事务的状态，并驱动分支事务提交或者回滚。</p></li></ul><p>这些概念可能有些晦涩，我们通过前面商城会员采购积分的例子进行讲解。</p><h3 id="Seata-AT-模式执行过程"><a href="#Seata-AT-模式执行过程" class="headerlink" title="Seata AT 模式执行过程"></a>Seata AT 模式执行过程</h3><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/9.png" alt="创建订单调用逻辑" loading="lazy"></p><center>创建订单调用逻辑</center><p>这里我先给出商城应用中会员采购业务的伪代码。</p><blockquote><p>会员采购(){<br>    订单服务.创建订单();<br>    积分服务.增加积分();<br>    库存服务.减少库存();<br>}</p></blockquote><p>在会员采购方法中，需要分别执行创建订单、增加积分、减少库存三个步骤完成业务，对于“会员采购”来说方法执行成功，则代表这个全局分布式事务需要提交，如果中间过程出错，则需要全局回滚，这个业务方法本身就决定了全局提交、回滚的时机以及决定了哪些服务需要参与业务处理，因此商城应用的会员采购方法就充当起事务管理器（TM）的角色。</p><p>而与之对应的在订单服务中创建订单、会员服务中增加积分、库存服务减少库存这些实际产生的数据处理的服务模块，则被称为资源管理器（RM)。</p><p>最后就是由Seata提供的Seata-Server中间件则提供事务协调者（TC）这个角色，实施全局事务1的提交、回滚命令下发。</p><p>为了方便理解，我画了时序图介绍 Seata 的执行过程。</p><p><img src="/2022/06/12/2022-06-12AlibabaSeata如何实现分布式事务/10.png" alt="Seata 时序图" loading="lazy"></p><center>Seata 时序图</center><p>第一步，在商城应用（TM）与三个服务（RM）启动后自动向事务协调者Seata-Server（TC）进行注册，让 TC 知晓各个组件的详细信息。</p><p>第二步，当会员购物时会执行 TM 的“会员采购”方法，当进入方法前 Seata 为 TM 提供的客户端会自动生效，向 TC 发出开启全局事务的请求。</p><p>第三步，会员采购方法开始执行，会依次执行 3 个服务的新增订单、增加积分、减少库存，在请求送往新的 RM 时，都会向 TC 注册新的分支事务。这些分支事务在处理时不但向业务表写入数据，还会自动向 Seata 强制要求的 UNDO_LOG 回滚日志表写入回滚 SQL 日志。</p><p>以新增订单事务为例：新增订单时执行的 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">order</span>(id,...) <span class="keyword">values</span>(<span class="number">1001</span>,...)</span><br></pre></td></tr></table></figure><p>与之对应的，Seata 的回滚日志是基于 SQL 反向生成，新增订单创建了 1001 订单，那 Seata会对 SQL 进行解析生成反向的回滚 SQL 日志保存在 UNDO_LOG 表，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">order</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure><p>与之类似会员积分会生成加积分的业务 SQL 以及减积分的回滚 SQL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#加积分</span><br><span class="line">UPDATE <span class="keyword">FROM</span> points <span class="keyword">SET</span> point <span class="operator">=</span> <span class="number">180</span> <span class="operator">+</span> <span class="number">20</span> <span class="keyword">WHERE</span> mid <span class="operator">=</span> <span class="number">182</span></span><br><span class="line">#UNDO_LOG表中的减积分<span class="keyword">SQL</span></span><br><span class="line">UPDATE <span class="keyword">FROM</span> points <span class="keyword">SET</span> point <span class="operator">=</span> <span class="number">200</span> <span class="operator">-</span> <span class="number">20</span> <span class="keyword">WHERE</span> mid <span class="operator">=</span> <span class="number">182</span></span><br></pre></td></tr></table></figure><p>第四步，当 RM 的分支事务执行成功后，会自动向 TC 上报分支事务处理成功。</p><p>第五步，当会员采购方法正确执行，所有 RM 也向 TC 上报分支事务处理成功，在“会员采购”方法退出前，TM 内置的 Seata 客户端会向 TC 自动发起“提交全局事务”请求。TC 收到“提交全局事务”请求，向所有 RM 下达提交分支事务的命令，每一个 RM 在收到提交命令后，会删除之前保存在 UNDO_LOG 表中的回滚日志。</p><p>但是事情总会有意外，假设某个 RM 分支事务处理失败，此时 TM 便不再向 TC 发起“提交全局事务”，转而发送“回滚全局事务”，TC 收到后，通知所有之前已处理成功的 RM 执行回滚 SQL 将数据回滚。</p><p>比如 1001 订单在第三步“减少库存”时发现库存不足导致库存服务预处理失败，那全局回滚时第一步订单服务会自动执行删除 1001 订单的回滚 SQL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">order</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure><p>以及第二步积分服务会自动执行减少积分的回滚 SQL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE <span class="keyword">FROM</span> points <span class="keyword">SET</span> point <span class="operator">=</span> <span class="number">200</span> <span class="operator">-</span> <span class="number">20</span> <span class="keyword">WHERE</span> mid <span class="operator">=</span> <span class="number">182</span></span><br></pre></td></tr></table></figure><p>Seata AT模式就是通过执行反向 SQL 达到数据还原的目的，当反向 SQL 执行后便自动从 UNDO_LOG 表中删除。这便是 Seata AT 模式的大致执行过程，在这个过程中我们发现 Seata AT 模式设计的巧妙之处，Seata 为了能做到无侵入的自动实现全局事务提交与回滚，它在 TM端利用了类似于“Spring 声明式事务”的设计，在进入 TM 方法前通知 TC 开启全局事务，在成功执行后自动提交全局事务，执行失败后进行全局回滚。同时在 RM 端也巧妙的采用了 SQL 解析技术自动生成了反向的回滚 SQL 来实现数据还原。</p><p>在这我也思考过，为什么 Seata 要生成反向 SQL，而不是利用数据库自带的排他锁机制处理呢？翻阅资料后理解到它的设计意图，如果采用排它锁机制会导致数据资源被锁死，可能会产生大量的数据资源阻塞，进而存在应用崩溃的风险。而生成反向 SQL 的方案则是在预处理阶段事务便已提交，不会出现长时间数据资源锁定的情况，这样能有效提高并发量。但这样做也有弊端，在研究时发现 Seata 是工作在“读未提交”的隔离级别，高并发环境下容易产生脏读、幻读的情况，这也是需要特别注意的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式事务：Alibaba-Seata-如何实现分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务：Alibaba-Seata-如何实现分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务：Alibaba Seata 如何实现分布式事务&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于SkyWalking实施链路追踪</title>
    <link href="2022/06/05/2022-06-05%E5%9F%BA%E4%BA%8ESkyWalking%E5%AE%9E%E6%96%BD%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>2022/06/05/2022-06-05%E5%9F%BA%E4%BA%8ESkyWalking%E5%AE%9E%E6%96%BD%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</id>
    <published>2022-06-05T07:20:14.000Z</published>
    <updated>2022-06-12T14:00:02.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用性能监控：通过-SkyWalking-实施链路追踪"><a href="#应用性能监控：通过-SkyWalking-实施链路追踪" class="headerlink" title="应用性能监控：通过 SkyWalking 实施链路追踪"></a>应用性能监控：通过 SkyWalking 实施链路追踪</h1><h2 id="APM-与-SkyWalking"><a href="#APM-与-SkyWalking" class="headerlink" title="APM 与 SkyWalking"></a>APM 与 SkyWalking</h2><p>这些年随着微服务体系的不断完善，链路追踪已经不是什么新兴的概念与技术，很多厂商也提供了自己的链路追踪产品，例如 Spring Cloud Slueth、Zipkin、阿里鹰眼、大众点评 Cat、SkyWalking 等。但这些产品都有一个共同的名字：APM（Application Performance Management），即应用性能管理系统。顾名思义这些产品的根本目的就是对应用程序单点性能与整个分布式应用进行监控，记录每一个环节程序执行状况，通过图表与报表的形式让运维人员随时掌握系统的运行状况，其中在这些著名的产品中我非常推荐各位掌握 SkyWalking 这款 APM 产品，理由很简单，它在简单易用的前提下实现了比 Zipkin 功能更强大的链路追踪、同时拥有更加友好、更详细的监控项，并能自动生成可视化图表。相比 Sleuth+Zipkin 这种不同厂商间混搭组合，SkyWalking 更符合国内软件业的“一站式解决方案”的设计理念，下面咱们来了解下 SKyWalking。</p><p>SkyWalking 是中国人吴晟（华为）开源的应用性能管理系统（APM）工具，使用Java语言开发，后来吴晟将其贡献给 Apache，在 Apache 的背书下 SkyWalking 发展迅速，现在已属于 Apache 旗下顶级开源项目，它的官网：<a class="link" href="http://skywalking.apache.org/">http://skywalking.apache.org/<i class="fas fa-external-link-alt"></i></a> 。</p><p>SkyWalking 提供了分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。</p><p>对比 Sleuth+Zipkin 与 SkyWalking 做对比，看两者的优劣。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/1.png" alt="Sleuth+Zipkin 与 SkyWalking 对比" loading="lazy"></p><p>通过比较我们可以发现，在易用性和使用体验上，SkyWalking 明显好于 Zipkin，功能更丰富的同时也更符合国人习惯，但因为迭代速度较快，社区文档相对陈旧，这也导致很多技术问题需要程序员自己研究解决，因此在解决问题方面需要更多的时间。</p><h2 id="部署-SkyWalking-服务端与-Java-Agent"><a href="#部署-SkyWalking-服务端与-Java-Agent" class="headerlink" title="部署 SkyWalking 服务端与 Java Agent"></a>部署 SkyWalking 服务端与 Java Agent</h2><h3 id="部署-SkyWalking-服务端"><a href="#部署-SkyWalking-服务端" class="headerlink" title="部署 SkyWalking 服务端"></a>部署 SkyWalking 服务端</h3><p>首先咱们要理解 SkyWalking 架构图</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/2.png" alt="SkyWalking 的架构图" loading="lazy"></p><center>SkyWalking 的架构图</center><p>SkyWalking 同样采用客户端与服务端架构模式，SkyWalking 服务端用于接收来自 Java Agent 客户端发来的链路跟踪与指标数据，汇总统计后由 SkyWalking UI 负责展现。SkyWalking 服务端同时支持 gRPC 与 HTTP 两种上报方式。其中 gRPC 默认监听服务器 11800 端口，HTTP 默认监听 12800 端口，而 SKyWalking UI 应用则默认监听 8080 端口，这三个端口在生产环境下要在防火墙做放行配置。在存储层面，SkyWalking 底层支持 ElasticSearch 、MySQL、H2等多种数据源，官方优先推荐使用 ElasticSearch，如果此时你不会 ElasticSearch 也没关系，按文中步骤操作也能完成部署。</p><p>首先咱们根据架构图部署 SkyWalking 服务端。</p><h4 id="第一步，安装-ElasticSearch-全文检索引擎"><a href="#第一步，安装-ElasticSearch-全文检索引擎" class="headerlink" title="第一步，安装 ElasticSearch 全文检索引擎"></a>第一步，安装 ElasticSearch 全文检索引擎</h4><p>ElasticSearch 简称 ES，是业内最著名的全文检索引擎，常用于构建站内搜索引擎，SkyWalking 官方推荐使用 ES 作为数据存储组件。这里直接访问 ES 官网下载页：</p><p><a class="link" href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch<i class="fas fa-external-link-alt"></i></a></p><p>下载对应平台的 ES 服务器程序。</p><p>下载后会得到 elasticsearch-7.17.4-linux-x86_64.tar.gz 文件，解压缩后无须任何修改直接运行 bin/elasticsearch.bat 文件，如果是 Linux 系统则运行 elasticsearch.sh 文件。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/3.png" alt="ElasticSearch 启动成功画面" loading="lazy"></p><center>ElasticSearch 启动成功画面</center><p>默认 ES 监听 9200 与 9300 端口，其中 9200 是 ES 对外提供服务的端口；9300 是 ES 进行集群间通信与数据传输的端口，请确保这两个端口没有被占用。</p><h4 id="第二步，下载-SkyWalking"><a href="#第二步，下载-SkyWalking" class="headerlink" title="第二步，下载 SkyWalking"></a>第二步，下载 SkyWalking</h4><p>访问 <a class="link" href="https://skywalking.apache.org/downloads/">https://skywalking.apache.org/downloads/<i class="fas fa-external-link-alt"></i></a></p><p>下载 apache-skywalking-apm-es7-8.7.0.tar.gz</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/4.png" alt="SkyWalking 下载页" loading="lazy"></p><center>SkyWalking 下载页</center><h4 id="第三步，配置-SkyWalking-数据源"><a href="#第三步，配置-SkyWalking-数据源" class="headerlink" title="第三步，配置 SkyWalking 数据源"></a>第三步，配置 SkyWalking 数据源</h4><p>SKyWalking 收集到的数据要被存储在 ElasticSearch 中，因此需要指定数据源。在 config 目录下找到 application.yml，这是 SkyWalking 的核心配置文件。</p><p>在配置文件 找到 storage 配置片段。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="string">$&#123;SW_STORAGE:h2&#125;</span></span><br><span class="line">  <span class="attr">elasticsearch:</span> <span class="comment">#ES6配置 </span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">elasticsearch:</span> <span class="comment">#ES配置</span></span><br><span class="line">    <span class="attr">nameSpace:</span> <span class="string">$&#123;SW_NAMESPACE:&quot;&quot;&#125;</span></span><br><span class="line">    <span class="attr">clusterNodes:</span> <span class="string">$&#123;SW_STORAGE_ES_CLUSTER_NODES:localhost:9200&#125;</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">$&#123;SW_STORAGE_ES_HTTP_PROTOCOL:&quot;http&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>默认 SkyWalking 采用内置 H2 数据库存储监控数据，现在需要改为 elasticsearch，这样就完成了数据源存储的切换，在启动时 SkyWalking 会自动初始化 ES 的索引。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span> <span class="string">$&#123;SW_STORAGE:elasticsearch7&#125;</span></span><br></pre></td></tr></table></figure><p>到这里，SkyWalking 数据源配置成功。</p><h4 id="第四步，启动-SkyWalking-应用"><a href="#第四步，启动-SkyWalking-应用" class="headerlink" title="第四步，启动 SkyWalking 应用"></a>第四步，启动 SkyWalking 应用</h4><p>在 bin 目录下找到 startup.bat 运行，如果是 Linux 系统运行 startup.sh。</p><p>启动后会产生两个 Java 进程：</p><p>Skywalking-Collector 是数据收集服务，默认监听 11800（gRPC）与 12800（HTTP） 端口。</p><p>Skywalking-Webapp 是 SkyWalking UI，用于展示数据，默认监听 8080 端口。</p><p>启动成功后，访问<a class="link" href="http://localhost:8080/">http://localhost:8080/<i class="fas fa-external-link-alt"></i></a> ，如果看到 SkyWalking UI 首页，则说明服务端配置成功。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/5.png" alt="SkyWalking UI 首页" loading="lazy"></p><center>SkyWalking UI 首页</center><h3 id="安装-SkyWalking-Java-Agent"><a href="#安装-SkyWalking-Java-Agent" class="headerlink" title="安装 SkyWalking Java Agent"></a>安装 SkyWalking Java Agent</h3><p>在前面提到，SkyWalking 可以在不修改应用源码的前提下，无侵入的实现链路追踪与 JVM 指标监控，它是怎么做到的？这里涉及一个 Java1.5 新增的特性，Java Agent 探针技术，想必对于很多工作多年 Java 工程师来说，Java Agent 也是一个陌生的东西。</p><p>Java Agent 探针说白了就是 Java 提供的一种“外挂”技术，允许在应用开发的时候在通过启动时增加 java agent 参数来外挂一些额外的程序。</p><p>Java Agent 并不复杂，其扩展类有着严格的规范，必须创建名为 premain 的方法，该方法将在目标应用 main 方法前执行，下面就是最简单的 Java Agent 扩展类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========开始执行premain============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要完成 Java Agent，还需要提供正确的 MANIFEST.MF，以便 JVM 能够选择正确的类。在 META-INF 目录下找到你的 MANIFEST.MF 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.lagou.agent.SimpleAgent</span><br></pre></td></tr></table></figure><p>之后我们将这个类打包为 agent.jar，假设原始应用为 oa.jar，在 oa.jar 启动时需要在额外附加 javaagent 参数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:agent.jar -jar oa.jar</span><br></pre></td></tr></table></figure><p>在应用启动时 Java 控制台会输出如下日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=========开始执行 premain============</span><br><span class="line">正在启动 OA 办公自动化系统...</span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过结果你会发现 java agent 在目标应用main执行前先执行了premain，实现了不修改OA源码的前提下增加了新的功能。</p><p>SkyWalking 也是利用 Java Agent 的特性，在 premain 中通过字节码增强技术对目标方法进行扩展，当目标方法执行时自动收集链路追踪及监控数据并发往 SkyWalking 服务端。</p><p>下面咱们来讲解如何加载并使用 SkyWalking Java Agent，我们还是以实例进行讲解，因为 Java Agent 是无侵入的，并不需要源码，这里我就直接给出调用关系图帮助咱们理解。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/6.png" alt="调用关系图" loading="lazy"></p><center>调用关系图</center><p>简单介绍下，用户访问 a 服务的 a 接口，a 服务通过 OpenFeign 远程调用 b 服务的 b 接口，b 服务通过 OpenFeign 调用 c 服务的 c 接口，最后 c 接口通过 JDBC 将业务数据存储到 MySQL 数据库。</p><p>下面咱们演示 SkyWalking Java Agent 的用法，在 skywalking 的 agent 目录下存在 skywalking-agent.jar，这就是 skywalking 提供的 Java Agent 扩展类。</p><p>如果是生产环境下在启动应用时附加 javaagent 参数即可。</p><p>a 服务启动命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:D:\Develop\env\skywalking-agent\skywalking-agent.jar -Dskywalking.agent.service_name=a-service -Dskywalking.collector.backend_service=127.0.0.1:11800 -Dskywalking.logging.file_name=a-service-api.log -jar a-service.jar</span><br></pre></td></tr></table></figure><p>b 服务启动命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:D:\Develop\env\skywalking-agent\skywalking-agent.jar -Dskywalking.agent.service_name=b-service -Dskywalking.collector.backend_service=127.0.0.1:11800 -Dskywalking.logging.file_name=b-service-api.log -jar b-service.jar</span><br></pre></td></tr></table></figure><p>c 服务启动命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:D:\Develop\env\skywalking-agent\skywalking-agent.jar -Dskywalking.agent.service_name=c-service -Dskywalking.collector.backend_service=127.0.0.1:11800 -Dskywalking.logging.file_name=c-service-api.log -jar c-service.jar</span><br></pre></td></tr></table></figure><p>如果是在 idea 开发环境运行，需要在 VM options 附加 javaagent。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/7.png" alt="IDEA 中使用 SkyWalking Java Agent" loading="lazy"></p><center>IDEA 中使用 SkyWalking Java Agent</center><p>除了 javaagent 指定具体 agent 文件外，agent 本身也支持一系列配置参数，在刚才的启动时涉及 3 个。</p><ul><li><p><strong>skywalking.agent.service_name</strong>：指定在 SkyWalking 上报数据时的服务名。</p></li><li><p><strong>skywalking.collector.backend_service</strong>：指定 SkyWalking 服务端的通信IP与端口。</p></li><li><p><strong>skywalking.logging.file_name</strong>：指定 agent 生成的上报日志文件名，日志文件保存 agent 的 logs 目录中。</p></li></ul><h2 id="介绍-SkyWalking-常用视图"><a href="#介绍-SkyWalking-常用视图" class="headerlink" title="介绍 SkyWalking 常用视图"></a>介绍 SkyWalking 常用视图</h2><p>当服务启动后，为了演示需要，我利用 PostMan 对 a 接口模拟 10000次 用户访问，看 SkyWalking UI 中产生哪些变化。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/8.png" alt="PostMan 压力测试" loading="lazy"></p><center>PostMan 压力测试</center><p>此时访问<a class="link" href="http://192.168.31.10:8080/">http://192.168.31.10:8080/<i class="fas fa-external-link-alt"></i></a> ，打开 SKyWalking UI，默认显示全局的应用性能，具体用途我已在图中标出，其中我认为比较重要的是服务状态指数与高延迟端点列表两项，服务状态指数越接近 1 代表该服务运行状况越好，而高延迟端点列表则将处理延迟高的 API 端点列出，这可能是我们重点排查与优化的对象。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/9.png" alt="全局监控" loading="lazy"></p><center>全局监控</center><p>除了全局监控外，SkyWalking 链路追踪的展示也非常友好，点击“拓扑”按钮可以查看访问拓扑图。服务间依赖关系一目了然。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/10.png" alt="拓扑图" loading="lazy"></p><center>拓扑图</center><p>除此之外，链路追踪的展示也非常强大，服务间的 API 调用关系与执行时间、调用状态清晰列出，而且因为 SkyWalking 是方法层面上的扩展，会提供更加详细的方法间的调用过程。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/11.png" alt="链路追踪图" loading="lazy"></p><center>链路追踪图</center><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/12.png" alt="提供不同维度的视图" loading="lazy"></p><center>提供不同维度的视图</center><p>SkyWalking 基于 Java Agent 对数据库的运行指标也进行收集，点击”database”便进入数据库指标监控。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/13.png" alt="数据库视图" loading="lazy"></p><center>数据库视图</center><p>如果你用过 SkyWalking 一定会被它简单的使用方法与强大的功能所折服，在SkyWalking提供了多达几十种不同维度、不同方式的数据展示方案，例如基于服务实例的JVM检测仪表盘就能让我们了解该服务 JVM 的资源分配过程，分析其中潜在的问题。</p><p><img src="/2022/06/05/2022-06-05基于SkyWalking实施链路追踪/14.png" alt="服务实例的 JVM 监控" loading="lazy"></p><center>服务实例的 JVM 监控</center><p>当然 SKyWalking 也不是全能的，在生产环境下 SkyWalking 还需要额外考虑很多问题，如 SkyWalking 的集群管理、访问权限控制、自监控、风险预警等都要逐步完善，因此很多互联网公司也基于 SkyWalking 做二次开发以满足自身的需求，希望你也能在使用过程中对 SkyWalking 的潜力进行挖掘、了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;应用性能监控：通过-SkyWalking-实施链路追踪&quot;&gt;&lt;a href=&quot;#应用性能监控：通过-SkyWalking-实施链路追踪&quot; class=&quot;headerlink&quot; title=&quot;应用性能监控：通过 SkyWalking 实施链路追踪&quot;&gt;&lt;/a&gt;应用性能监</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于Sleuth+Zipkin实施链路跟踪体系</title>
    <link href="2022/06/04/2022-06-04%E5%9F%BA%E4%BA%8ESleuth-Zipkin%E5%AE%9E%E6%96%BD%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E4%BD%93%E7%B3%BB/"/>
    <id>2022/06/04/2022-06-04%E5%9F%BA%E4%BA%8ESleuth-Zipkin%E5%AE%9E%E6%96%BD%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E4%BD%93%E7%B3%BB/</id>
    <published>2022-06-04T06:38:13.000Z</published>
    <updated>2022-06-05T07:24:58.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链路跟踪：基于-Sleuth-Zipkin-实施链路跟踪体系"><a href="#链路跟踪：基于-Sleuth-Zipkin-实施链路跟踪体系" class="headerlink" title="链路跟踪：基于 Sleuth+Zipkin 实施链路跟踪体系"></a>链路跟踪：基于 Sleuth+Zipkin 实施链路跟踪体系</h1><h2 id="微服务链路追踪"><a href="#微服务链路追踪" class="headerlink" title="微服务链路追踪"></a>微服务链路追踪</h2><p>都知道在微服务架构下，系统的功能是由大量的微服务协调组成的，例如：电商创建订单业务就需要订单服务、库存服务、支付服务、短信通知服务逐级调用才能完成。而每个服务可能是由不同的团队进行开发，部署在成百上千台服务器上。</p><p><img src="/2022/06/04/2022-06-04基于Sleuth-Zipkin实施链路跟踪体系/1.png" alt="复杂的调用链路" loading="lazy"></p><center>复杂的调用链路</center><p>如此复杂的消息传递过程，当系统发生故障的时候，就需要一种机制对故障点进行快速定位，确认是哪个服务出了问题，链路追踪技术由此而生。所谓的链路追踪，就是运行时通过某种方式记录下服务之间的调用过程，在通过可视化的 UI 界面帮研发运维人员快速定位到出错点。引入链路追踪，是微服务架构运维的底层基础，没有它，运维人员就像盲人摸象一样，根本无法了解服务间通信过程。</p><p>在 Spring Cloud 标准生态下内置了 Sleuth 这个组件，它通过扩展 Logging 日志的方式实现微服务的链路追踪。说起来比较晦涩，咱们看一个实例就明白了，在标准的微服务下日志产生的格式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">01</span>-<span class="number">12</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">33.441</span> INFO [nio-<span class="number">7000</span>-exec-<span class="number">2</span>] c.netflix.config.ChainedDynamicProperty  : Flipping property: b-service.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = <span class="number">2147483647</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是当引入 Spring Cloud Sleuth 链路追踪组件后就会变成下面的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">01</span>-<span class="number">12</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">33.441</span>  INFO [a-service,5f70945e0eefa832,5f70945e0eefa832,<span class="keyword">true</span>] <span class="number">18404</span> --- [nio-<span class="number">7000</span>-exec-<span class="number">2</span>] c.netflix.config.ChainedDynamicProperty  : Flipping property: b-service.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = <span class="number">2147483647</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比较后会发现，在原有日志中额外附加了下面的文本</span><br><span class="line">[a-service,5f70945e0eefa832,5f70945e0eefa832,true]</span><br></pre></td></tr></table></figure><p>这段文本就是 Sleuth 在微服务日志中附加的链路调用数据，它的格式是固定的，包含以下四部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[微服务 Id,TraceId,SpanId,isExport]</span><br></pre></td></tr></table></figure><p><img src="/2022/06/04/2022-06-04基于Sleuth-Zipkin实施链路跟踪体系/2.png" alt="链路追踪数据的组成" loading="lazy"></p><center>链路追踪数据的组成</center><ul><li><p><strong>微服务 Id</strong>，说明日志是由哪个微服务产生的。</p></li><li><p><strong>TraceId</strong>，轨迹编号。一次完整的业务处理过程被称为轨迹，例如：实现登录功能需要从服务 A 调用服务 B，服务B再调用服务 C，那这一次登录处理的过程就是一个轨迹，从前端应用发来请求到接收到响应，每一次完整的业务功能处理过程都对应唯一的 TraceId。</p></li><li><p><strong>SpanId</strong>，步骤编号。刚才要实现登录功能需要从服务 A 到服务 C 涉及 3 个微服务处理，按处理前后顺序，每一个微服务处理时日志都被赋予不同的 SpanId。一个 TraceId 拥有多个 SpanId，而 SpanId 只能隶属于某一个 TraceId。</p></li><li><p><strong>导出标识</strong>，当前这个日志是否被导出，该值为 true 的时候说明当前轨迹数据允许被其他链路追踪可视化服务收集展现。</p></li></ul><p>下面我们看一个完整的追踪数据实例：</p><p>我模拟了服务 A -&gt; 服务 B -&gt; 服务 C的调用链路，下面是分别产生的日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#服务 A 应用控制台日志</span><br><span class="line"></span><br><span class="line"><span class="number">2021</span>-<span class="number">01</span>-<span class="number">12</span> <span class="number">22</span>:<span class="number">16</span>:<span class="number">54.394</span> DEBUG [a-service,e8ca7047a782568b,e8ca7047a782568b,<span class="keyword">true</span>] <span class="number">21320</span> --- [nio-<span class="number">7000</span>-exec-<span class="number">1</span>] org.apache.tomcat.util.http.Parameters   : ...</span><br><span class="line"></span><br><span class="line">#服务 B 应用控制台日志</span><br><span class="line"></span><br><span class="line"><span class="number">2021</span>-<span class="number">01</span>-<span class="number">12</span> <span class="number">22</span>:<span class="number">16</span>:<span class="number">54.402</span> DEBUG [b-service,e8ca7047a782568b,b6aa80fb33e71de6,<span class="keyword">true</span>] <span class="number">21968</span> --- [nio-<span class="number">8000</span>-exec-<span class="number">2</span>] org.apache.tomcat.util.http.Parameters   : ...</span><br><span class="line"></span><br><span class="line">#服务 C 应用控制台日志</span><br><span class="line"></span><br><span class="line"><span class="number">2021</span>-<span class="number">01</span>-<span class="number">12</span> <span class="number">22</span>:<span class="number">16</span>:<span class="number">54.405</span> DEBUG [c-service,e8ca7047a782568b,537098c59827a242,<span class="keyword">true</span>] <span class="number">17184</span> --- [nio-<span class="number">9000</span>-exec-<span class="number">2</span>] org.apache.tomcat.util.http.Parameters   : ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，在 DEBUG 级别下链路追踪数据被打印出来，按调用时间先后顺序分别是 A 到 C 依次出现。因为是一次完整业务处理，TraceId 都是相同的，SpanId 却各不相同，这些日志都已经被 Sleuth 导出，可以被 ZipKin 收集展示。</p><p>Zipkin 是 推特的一个开源项目，它能收集各个服务实例上的链路追踪数据并可视化展现。刚才 ABC 服务控制台产生的日志在 ZipKin 的 UI 界面中会以链路追踪图表的形式展现。</p><p><img src="/2022/06/04/2022-06-04基于Sleuth-Zipkin实施链路跟踪体系/3.png" alt="链路追踪图表" loading="lazy"></p><center>链路追踪图表</center><p>通过这个图表可以非常直观的了解业务处理过程中服务间的依赖关系与处理时间、处理状态等信息，是开发运维人员进行故障分析时必要的工具。</p><p>下面咱们通过实例讲解如何在微服务架构中进行链路追踪。这个过程分为两个阶段：</p><ul><li><p>在服务中加入 Spring Cloud Sleuth 生成链路追踪日志；</p></li><li><p>通过 ZipKin 收集链路最终日志，生成可视化图表。</p></li></ul><h3 id="微服务整合-Sleuth"><a href="#微服务整合-Sleuth" class="headerlink" title="微服务整合 Sleuth"></a>微服务整合 Sleuth</h3><p>为了演示需要，这里创建 a-service、b-service、c-service 三个微服务工程，配置过程十分简单，我们把关键代码拿出来说明。</p><p><img src="/2022/06/04/2022-06-04基于Sleuth-Zipkin实施链路跟踪体系/4.png" alt="调用链路示意图" loading="lazy"></p><center>调用链路示意图</center><p>第一步，创建 a-service、b-service、c-service 三个 Spring Boot 工程，pom.xml 依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring Web应用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Nacos 客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--服务间通信组件OpenFeign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c-service的pom.xml依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为调用关系是服务 A 调用服务 B，服务 B 调用服务 C，所以在 A、B 两个服务中需要额外依赖 OpenFeign 实现服务间通信。</p><p>第二步，配置 ABC 服务的 application.yml，这三个配置文件除了应用名称与服务端口不同外，其他都一样。这里设置 A 服务端口为 7000，B 服务端口 8000，C 服务端口 9000。</p><p>第二步，配置 ABC 服务的 application.yml，这三个配置文件除了应用名称与服务端口不同外，其他都一样。这里设置 A 服务端口为 7000，B 服务端口 8000，C 服务端口 9000。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span> <span class="comment">#a:7000/b:8000/c:9000 </span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">a-service</span> <span class="comment">#a-service/b-service/c-service</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span> <span class="comment">#为演示需要，开启debug级别日志</span></span><br></pre></td></tr></table></figure><p>第三步，实现业务逻辑，代码如下：</p><p>c-service 工程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SampleController，methodC方法产生响应字符串“-&gt; Service C”，方法映射地址“/c”</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = <span class="string">&quot; -&gt; Service C&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b-service 工程。</p><p>CServiceFeignClient 通过 OpenFeign 实现了 C 服务的通信客户端，方法名为 methodC。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;c-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CServiceFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SampleController 通过 methodB 方法调用 methodC 的同时为响应附加的字符串“-&gt; Service B”，方法映射地址“/b”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CServiceFeignClient cService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/b&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = cService.methodC();</span><br><span class="line">        result = <span class="string">&quot; -&gt; Service B&quot;</span> + result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a-service 工程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BServiceFeignClient通过OpenFeign实现了B服务的通信客户端，方法名为methodB</span><br><span class="line"><span class="meta">@FeignClient(&quot;b-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BServiceFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/b&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SampleController 通过 methodA 方法调用 methodB 的同时，成为响应附加的字符串“-&gt; Service A”，方法映射地址“/a”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BServiceFeignClient bService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/a&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = bService.methodB();</span><br><span class="line">        result = <span class="string">&quot;-&gt; Service A&quot;</span> + result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个完整的调用链路已形成。在 3 个服务实例启动后，访问 A 实例<br>访问 <a class="link" href="http://localhost:7000/a">http://localhost:7000/a<i class="fas fa-external-link-alt"></i></a> 得到运行结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; ServiceA -&gt; Service B -&gt; Service C</span><br></pre></td></tr></table></figure><p>可以看到 ABC 三个服务按前后顺序依次产生结果，但目前在日志中并没有包含任何链路追踪数据，那如何引入 Sleuth 呢？</p><p>很简单，只需要打开三个服务工程的 pom.xml 文件分别引入 spring-cloud-starter-sleuth 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加Sleuth依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加入依赖后，重启服务，无须做任何额外设置，Spring Cloud Sleuth 便自动为日志增加了链路追踪数据，下面是经过我整理后的追踪数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#服务 A 应用控制台日志，已附加链路追踪数据</span><br><span class="line"></span><br><span class="line">2021-01-12 22:16:54.394 DEBUG [a-service,e8ca7047a782568b,e8ca7047a782568b,true] 21320 --- [nio-7000-exec-1] org.apache.tomcat.util.http.Parameters   : ...</span><br><span class="line"></span><br><span class="line">#服务 B 应用控制台日志</span><br><span class="line"></span><br><span class="line">2021-01-12 22:16:54.402 DEBUG [b-service,e8ca7047a782568b,b6aa80fb33e71de6,true] 21968 --- [nio-8000-exec-2] org.apache.tomcat.util.http.Parameters   : ...</span><br><span class="line"></span><br><span class="line">#服务 C 应用控制台日志</span><br><span class="line"></span><br><span class="line">2021-01-12 22:16:54.405 DEBUG [c-service,e8ca7047a782568b,537098c59827a242,true] 17184 --- [nio-9000-exec-2] org.apache.tomcat.util.http.Parameters   : ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然数据已产生，但如果在生产环境靠人工组织数以万计的链路日志显然不现实，我们还需要部署链路追踪数据的分析工具 ZipKin 来简化这个过程。</p><h3 id="构建-Zipkin-Server-实现链路追踪的可视化管理"><a href="#构建-Zipkin-Server-实现链路追踪的可视化管理" class="headerlink" title="构建 Zipkin Server 实现链路追踪的可视化管理"></a>构建 Zipkin Server 实现链路追踪的可视化管理</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链路跟踪：基于-Sleuth-Zipkin-实施链路跟踪体系&quot;&gt;&lt;a href=&quot;#链路跟踪：基于-Sleuth-Zipkin-实施链路跟踪体系&quot; class=&quot;headerlink&quot; title=&quot;链路跟踪：基于 Sleuth+Zipkin 实施链路跟踪体系&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Sentinel进阶应用场景</title>
    <link href="2022/05/28/2022-05-28Sentinel%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>2022/05/28/2022-05-28Sentinel%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2022-05-28T14:17:15.000Z</published>
    <updated>2022-06-04T06:11:40.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生产实践：Sentinel-进阶应用场景"><a href="#生产实践：Sentinel-进阶应用场景" class="headerlink" title="生产实践：Sentinel 进阶应用场景"></a>生产实践：Sentinel 进阶应用场景</h1><p>Sentinel 的 GitHub 文档。</p><p><a class="link" href="https://sentinelguard.io/zh-cn/docs/flow-control.html">https://sentinelguard.io/zh-cn/docs/flow-control.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="Sentinel-与-Nacos-整合实现规则持久化"><a href="#Sentinel-与-Nacos-整合实现规则持久化" class="headerlink" title="Sentinel 与 Nacos 整合实现规则持久化"></a>Sentinel 与 Nacos 整合实现规则持久化</h2><p>细心的你肯定在前面 Sentinel的使用过程中已经发现，当微服务重启以后所有的配置规则都会丢失，其中的根源是默认微服务将 Sentinel 的规则保存在 JVM 内存中，当应用重启后 JVM 内存销毁，规则就会丢失。为了解决这个问题，我们就需要通过某种机制将配置好的规则进行持久化保存，同时这些规则变更后还能及时通知微服务进行变更。</p><p>正好，上一讲我们讲解了 Nacos 配置中心的用法，无论是配置数据的持久化特性还是配置中心主动推送的特性都是我们需要的，因此 Nacos 自然就成了 Sentinel 规则持久化的首选。</p><p>本讲我们仍然通过实例讲解 Sentinel 与 Nacos 的整合过程。</p><h3 id="案例准备"><a href="#案例准备" class="headerlink" title="案例准备"></a>案例准备</h3><p>首先，咱们快速构建演示工程 sentinel-sample。</p><ol><li>利用 Spring Initializr 向导创建 sentinel-sample 工程，pom.xml 增加以下三项依赖。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Nacos 客户端 Starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Sentinel 客户端 Starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对外暴露 Spring Boot 监控指标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>配置 Nacos 与 Sentinel 客户端。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-sample</span> <span class="comment">#应用名&amp;微服务 id</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span> <span class="comment">#Sentinel Dashboard 通信地址</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">192.168</span><span class="number">.157</span><span class="number">.133</span><span class="string">:9100</span></span><br><span class="line">      <span class="attr">eager:</span> <span class="literal">true</span> <span class="comment">#取消控制台懒加载</span></span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment">#Nacos 通信地址</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">default-property-inclusion:</span> <span class="string">non_null</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span> <span class="comment">#将所有可用的监控指标项对外暴露</span></span><br><span class="line">      <span class="attr">exposure:</span> <span class="comment">#可以访问 /actuator/sentinel进行查看Sentinel监控项</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span> <span class="comment">#开启 debug 是学习需要，生产改为 info 即可</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在 sentinel-sample服务中，增加 SentinelSampleController 类，用于演示运行效果。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelSampleController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//演示用的业务逻辑类</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SampleService sampleService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流控测试接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test_flow_rule&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseObject <span class="title">testFlowRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//code=0 代表服务器处理成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseObject(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 熔断测试接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test_degrade_rule&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseObject <span class="title">testDegradeRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sampleService.createOrder();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalStateException e)&#123;</span><br><span class="line">            <span class="comment">//当 createOrder 业务处理过程中产生错误时会抛出IllegalStateException</span></span><br><span class="line">            <span class="comment">//IllegalStateException 是 JAVA 内置状态异常，在项目开发时可以更换为自己项目的自定义异常</span></span><br><span class="line">            <span class="comment">//出现错误后将异常封装为响应对象后JSON输出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseObject(e.getClass().getSimpleName(),e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseObject(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;order created!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，ResponseObject 对象封装了响应的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装响应数据的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String code; <span class="comment">//结果编码，0-固定代表处理成功</span></span><br><span class="line">    <span class="keyword">private</span> String message;<span class="comment">//响应消息</span></span><br><span class="line">    <span class="keyword">private</span> Object data;<span class="comment">//响应附加数据（可选）</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseObject</span><span class="params">(String code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Getter/Setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>额外增加 SampleService 用于模拟业务逻辑，等下我们将用它讲解自定义资源点与熔断设置。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示用的业务逻辑类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟创建订单业务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟处理业务逻辑需要101毫秒</span></span><br><span class="line">            Thread.sleep(<span class="number">101</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 sentinel-sample，访问<a class="link" href="http://localhost/test_flow_rule%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%87%BA%E7%8E%B0code=0">http://localhost/test_flow_rule，浏览器出现code=0<i class="fas fa-external-link-alt"></i></a> 的 JSON 响应，说明 sentinel-sample 服务启动成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;success!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流控规则持久化"><a href="#流控规则持久化" class="headerlink" title="流控规则持久化"></a>流控规则持久化</h3><p>工程创建完成，下面咱们将 Sentinel接入 Nacos 配置中心。</p><p>第一步，pom.xml 新增 sentinel-datasource-nacos 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>sentinel-datasource-nacos 是 Sentinel 为 Nacos 扩展的数据源模块，允许将规则数据存储在 Nacos 配置中心，在微服务启动时利用该模块 Sentinel 会自动在 Nacos下载对应的规则数据。</p><p>第二步，在application.yml 文件中增加 Nacos下载规则，在原有的sentinel 配置下新增 datasource 选项。这里咱们暂时只对流控规则进行设置，重要配置项我在代码中进行了注释，请同学们仔细阅读。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-sample</span> <span class="comment">#应用名&amp;微服务id</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span> <span class="comment">#Sentinel Dashboard通信地址</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:9100</span></span><br><span class="line">      <span class="attr">eager:</span> <span class="literal">true</span> <span class="comment">#取消控制台懒加载</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow:</span> <span class="comment">#数据源名称，可以自定义</span></span><br><span class="line">          <span class="attr">nacos:</span> <span class="comment">#nacos配置中心</span></span><br><span class="line">            <span class="comment">#Nacos内置配置中心，因此重用即可</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">$&#123;spring.cloud.nacos.server-addr&#125;</span> </span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-flow-rules</span> <span class="comment">#定义流控规则data-id，完整名称为:sentinel-sample-flow-rules，在配置中心设置时data-id必须对应。</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">SAMPLE_GROUP</span> <span class="comment">#gourpId对应配置文件分组，对应配置中心groups项</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> <span class="comment">#flow固定写死，说明这个配置是流控规则</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">nacos</span> <span class="comment">#nacos通信的用户名与密码</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment">#Nacos通信地址</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p>通过这一份配置，微服务在启动时就会自动从 Nacos 配置中心 SAMPLE_GROUP 分组下载 data-id 为 sentinel-sample-flow-rules 的配置信息并将其作为流控规则生效。</p><p>第三步，在 Nacos 配置中心页面，新增 data-id 为sentinel-sample-flow-rules 的配置项。</p><p><img src="/2022/05/28/2022-05-28Sentinel进阶应用场景/1.png" alt="流控规则设置" loading="lazy"></p><center>流控规则设置</center><p>这里 data-id 与 groups 与微服务应用的配置保持对应，最核心的配置内容采用 JSON 格式进行书写，我们来分析下这段流控规则。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;resource&quot;</span>:<span class="string">&quot;/test_flow_rule&quot;</span>, #资源名，说明对那个URI进行流控</span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span>:<span class="string">&quot;default&quot;</span>,  #命名空间，默认default</span><br><span class="line">        <span class="attr">&quot;grade&quot;</span>:<span class="number">1</span>, #类型 0-线程 1-QPS</span><br><span class="line">        <span class="attr">&quot;count&quot;</span>:<span class="number">2</span>, #超过2个QPS限流将被限流</span><br><span class="line">        <span class="attr">&quot;strategy&quot;</span>:<span class="number">0</span>, #限流策略: <span class="number">0</span>-直接 <span class="number">1</span>-关联 <span class="number">2</span>-链路</span><br><span class="line">        <span class="string">&quot;controlBehavior&quot;</span>:<span class="number">0</span>, #控制行为: <span class="number">0</span>-快速失败 <span class="number">1</span>-WarmUp <span class="number">2</span>-排队等待</span><br><span class="line">        <span class="string">&quot;clusterMode&quot;</span>:<span class="literal">false</span> #是否集群模式</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>仔细观察不难发现，这些配置项与 Dashboard UI 中的选项是对应的，其实使用 DashboardUI 最终目的是为了生成这段 JSON 数据而已，只不过通过 UI 更容易使用罢了。</p><p><img src="/2022/05/28/2022-05-28Sentinel进阶应用场景/2.png" alt="Sentinel Dashboard 流控设置界面" loading="lazy"></p><center>Sentinel Dashboard 流控设置界面</center><p>最后，我们启动应用来验证流控效果。</p><p>访问 <a class="link" href="http://localhost/test_flow_rule%EF%BC%8C%E5%9C%A8%E6%97%A5%E5%BF%97%E4%B8%AD%E5%B0%86%E4%BC%9A%E7%9C%8B%E5%88%B0%E8%BF%99%E6%9D%A1">http://localhost/test_flow_rule，在日志中将会看到这条<i class="fas fa-external-link-alt"></i></a> Debug 信息，说明在服务启动时已向 Nacos 配置中心获取到流控规则。</p><p>在浏览器反复刷新，当 test_flow_rule 接口每秒超过 2 次访问，就会出现“Blocked by Sentinel (flow limiting)”的错误信息，说明流控规则已生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>-<span class="number">05</span>-<span class="number">29</span> <span class="number">18</span>:<span class="number">36</span>:<span class="number">27.104</span> DEBUG <span class="number">29100</span> --- [<span class="number">68.157</span><span class="number">.132_8848</span>] s.n.www.protocol.http.HttpURLConnection  : sun.net.www.MessageHeader@14e3aa7815 pairs: &#123;GET /nacos/v1/cs/configs?dataId=sentinel-sample-flow-rules&amp;accessToken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTY1MzgzODM1OH0.L66LVRePT-2_onvSUUHDI2DSUP1l-6HT9FNhtu852MI&amp;group=SAMPLE_GROUP HTTP/<span class="number">1.1</span>: <span class="keyword">null</span>&#125;&#123;Content-Type: application/json&#125;&#123;Accept-Charset: UTF-<span class="number">8</span>&#125;&#123;Accept-Encoding: gzip&#125;&#123;Content-Encoding: gzip&#125;&#123;Client-AppName: unknown&#125;&#123;Client-RequestTS: <span class="number">1653820587104</span>&#125;&#123;Client-RequestToken: 4c84e7b9eb2c0c7fccb596d5c99a240c&#125;&#123;Client-Version: <span class="number">1.3</span><span class="number">.2</span>&#125;&#123;exConfigInfo: <span class="keyword">true</span>&#125;&#123;RequestId: 315872c7-<span class="number">760d</span>-49a8-<span class="number">98e7</span>-38f8373ca541&#125;&#123;User-Agent: Java/<span class="number">1.8</span><span class="number">.0_241</span>&#125;&#123;Host: <span class="number">192.168</span><span class="number">.157</span><span class="number">.131</span>:<span class="number">8848</span>&#125;&#123;Accept: text/html, image/gif, image/jpeg, *; q=<span class="number">.2</span>, *<span class="comment">/*; q=.2&#125;&#123;Connection: keep-alive&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><p>之后我们再来验证能否自动推送新规则，将Nacos 配置中心中流控规则 count 选项改为 1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;resource&quot;</span>:<span class="string">&quot;/test_flow_rule&quot;</span>, </span><br><span class="line">        <span class="string">&quot;limitApp&quot;</span>:<span class="string">&quot;default&quot;</span>,</span><br><span class="line">        <span class="string">&quot;grade&quot;</span>:<span class="number">1</span>, </span><br><span class="line">        <span class="string">&quot;count&quot;</span>:<span class="number">1</span>, #<span class="number">2</span>改为<span class="number">1</span> </span><br><span class="line">        <span class="string">&quot;strategy&quot;</span>:<span class="number">0</span>, </span><br><span class="line">        <span class="string">&quot;controlBehavior&quot;</span>:<span class="number">0</span>, </span><br><span class="line">        <span class="string">&quot;clusterMode&quot;</span>:<span class="literal">false</span> </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当新规则发布后，sentinel-sample控制台会立即收到下面的日志，说明新的流控规则即时生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>-<span class="number">05</span>-<span class="number">29</span> <span class="number">18</span>:<span class="number">45</span>:<span class="number">10.998</span> DEBUG <span class="number">29100</span> --- [<span class="number">68.157</span><span class="number">.132_8848</span>] s.n.www.protocol.http.HttpURLConnection  : sun.net.www.MessageHeader@361282d815 pairs: &#123;GET /nacos/v1/cs/configs?dataId=sentinel-sample-flow-rules&amp;accessToken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTY1MzgzODM1OH0.L66LVRePT-2_onvSUUHDI2DSUP1l-6HT9FNhtu852MI&amp;group=SAMPLE_GROUP HTTP/<span class="number">1.1</span>: <span class="keyword">null</span>&#125;&#123;Content-Type: application/json&#125;&#123;Accept-Charset: UTF-<span class="number">8</span>&#125;&#123;Accept-Encoding: gzip&#125;&#123;Content-Encoding: gzip&#125;&#123;Client-AppName: unknown&#125;&#123;Client-RequestTS: <span class="number">1653821110997</span>&#125;&#123;Client-RequestToken: 5f5d1e11a7960725cb05df4d27568566&#125;&#123;Client-Version: <span class="number">1.3</span><span class="number">.2</span>&#125;&#123;exConfigInfo: <span class="keyword">true</span>&#125;&#123;RequestId: 832b07fe-f1bf-4dc8-97c3-2f1ad3288d92&#125;&#123;User-Agent: Java/<span class="number">1.8</span><span class="number">.0_241</span>&#125;&#123;Host: <span class="number">192.168</span><span class="number">.157</span><span class="number">.131</span>:<span class="number">8848</span>&#125;&#123;Accept: text/html, image/gif, image/jpeg, *; q=<span class="number">.2</span>, *<span class="comment">/*; q=.2&#125;&#123;Connection: keep-alive&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><p>在无须重启的情况下，test_flow_rule 接口 QPS 超过 1 就会直接报错。</p><p>与此同时，我们还可以通过 Spring Boot Actuator 提供的监控指标确认流控规则已生效。</p><p>访问 <a class="link" href="http://localhost/actuator/sentinel">http://localhost/actuator/sentinel<i class="fas fa-external-link-alt"></i></a> ,在 flowRules 这个数组中，可以看到 test_flow_rule 的限流规则，每一次流控规则产生改变时 Nacos 都会主动推送到微服务并立即生效。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;appName&quot;</span>: <span class="string">&quot;sentinel-sample&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;consoleServer&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;r1&quot;</span>: <span class="string">&quot;192.168.157.133&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;r2&quot;</span>: <span class="number">9100</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;coldFactor&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;systemRules&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;authorityRule&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;paramFlowRule&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;flowRules&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;/test_flow_rule&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;grade&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;count&quot;</span>: <span class="number">2.0</span>,</span><br><span class="line">                <span class="attr">&quot;strategy&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;controlBehavior&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;warmUpPeriodSec&quot;</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="attr">&quot;maxQueueingTimeMs&quot;</span>: <span class="number">500</span>,</span><br><span class="line">                <span class="attr">&quot;clusterMode&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;degradeRules&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;createOrder&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;grade&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;count&quot;</span>: <span class="number">100.0</span>,</span><br><span class="line">                <span class="attr">&quot;timeWindow&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">&quot;minRequestAmount&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;slowRatioThreshold&quot;</span>: <span class="number">0.1</span>,</span><br><span class="line">                <span class="attr">&quot;statIntervalMs&quot;</span>: <span class="number">1000</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;metricsFileCharset&quot;</span>: <span class="string">&quot;UTF-8&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="number">-2147483648</span>,</span><br><span class="line">        <span class="attr">&quot;urlPatterns&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;/**&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;totalMetricsFileCount&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">&quot;datasource&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;degrade&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;nacos&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;dataType&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ruleType&quot;</span>: <span class="string">&quot;DEGRADE&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;serverAddr&quot;</span>: <span class="string">&quot;192.168.157.131:8848,192.168.157.130:8848,192.168.157.132:8848&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;groupId&quot;</span>: <span class="string">&quot;SAMPLE_GROUP&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;dataId&quot;</span>: <span class="string">&quot;sentinel-sample-degrade-rules&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;flow&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;nacos&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;dataType&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ruleType&quot;</span>: <span class="string">&quot;FLOW&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;serverAddr&quot;</span>: <span class="string">&quot;192.168.157.131:8848,192.168.157.130:8848,192.168.157.132:8848&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;groupId&quot;</span>: <span class="string">&quot;SAMPLE_GROUP&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;dataId&quot;</span>: <span class="string">&quot;sentinel-sample-flow-rules&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;clientIp&quot;</span>: <span class="string">&quot;192.168.157.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clientPort&quot;</span>: <span class="string">&quot;8719&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;logUsePid&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;metricsFileSize&quot;</span>: <span class="number">52428800</span>,</span><br><span class="line">    <span class="attr">&quot;logDir&quot;</span>: <span class="string">&quot;C:\\Users\\87762\\logs\\csp\\&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;heartbeatIntervalMs&quot;</span>: <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>新的流控规则</center><h3 id="自定义资源点进行熔断保护"><a href="#自定义资源点进行熔断保护" class="headerlink" title="自定义资源点进行熔断保护"></a>自定义资源点进行熔断保护</h3><p>讲到这，我们已经实现了 test_flow_rule 接口的流控规则，但你发现了没有，在前面一系列 Sentinel 的讲解中我们都是针对 RESTful 的接口进行限流熔断设置，但是在项目中有的时候是要针对某一个 Service 业务逻辑方法进行限流熔断等规则设置，这要怎么办呢？</p><p>在 sentinel-core 客户端中为开发者提供了 @SentinelResource 注解，该注解允许在程序代码中自定义 Sentinel 资源点来实现对特定方法的保护，下面我们以熔断降级规则为例来进行讲解。熔断降级是指在某个服务接口在执行过程中频繁出现故障的情况下，在一段时间内将服务停用的保护措施。</p><p>在 sentinel-core 中基于 Spring AOP（面向切面技术）可在目标 Service 方法执行前按熔断规则进行检查，只允许有效的数据被送入目标方法进行处理。</p><p>还是以 sentinel-sample 工程为例，我希望对 SampleSerivce.createOrder方法进行熔断保护，该如何设置呢？</p><p><strong>第一步，声明切面类。</strong></p><p>在应用入口 SentinelSampleApplication声明 SentinelResourceAspect，SentinelResourceAspect就是 Sentinel 提供的切面类，用于进行熔断的前置检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelSampleApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解支持的配置Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SentinelResourceAspect <span class="title">sentinelResourceAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SentinelResourceAspect();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SentinelSampleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步，声明资源点。</strong></p><p>在 SampleService.createOrder 方法上增加 @SentinelResource 注解用于声明 Sentinel 资源点，只有声明了资源点，Sentinel 才能实施限流熔断等保护措施。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示用的业务逻辑类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//资源点名称为createOrder</span></span><br><span class="line">    <span class="meta">@SentinelResource(&quot;createOrder&quot;)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟创建订单业务</span></span><br><span class="line"><span class="comment">     * 抛出IllegalStateException异常用于模拟业务逻辑执行失败的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟处理业务逻辑需要101毫秒</span></span><br><span class="line">            Thread.sleep(<span class="number">101</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完毕，启动服务访问 <a class="link" href="http://localhost/test_degrade_rule">http://localhost/test_degrade_rule<i class="fas fa-external-link-alt"></i></a> ，当见到 code=0 的JSON 响应便代表应用运行正常。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    message: <span class="string">&quot;order created!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开访问 Sentinel Dashboard，在簇点链路中要确认 createOrder资源点已存在。</p><p><img src="/2022/05/28/2022-05-28Sentinel进阶应用场景/3.png" alt="createOrder 资源点已生效" loading="lazy"></p><center>createOrder 资源点已生效</center><p><strong>第三步，获取熔断规则。</strong></p><p>打开sentinel-sample 工程的 application.yml 文件，将服务接入 Nacos 配置中心的参数以获取熔断规则。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">flow:</span> <span class="comment">#之前的流控规则，直接忽略</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">degrade:</span> <span class="comment">#熔断规则</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">$&#123;spring.cloud.nacos.server-addr&#125;</span></span><br><span class="line">      <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-degrade-rules</span></span><br><span class="line">      <span class="attr">groupId:</span> <span class="string">SAMPLE_GROUP</span></span><br><span class="line">      <span class="attr">rule-type:</span> <span class="string">degrade</span> <span class="comment">#代表熔断</span></span><br><span class="line">     <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">     <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure><p>熔断规则的获取过程和前面流控规则类似，只不过 data-id 改为sentinel-sample-degrade-rules，以及 rule-type 更改为 degrade。</p><p>启动过程中，出现下面日志代表配置成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>-<span class="number">05</span>-<span class="number">29</span> <span class="number">19</span>:<span class="number">47</span>:<span class="number">33.057</span> DEBUG <span class="number">7396</span> --- [           main] s.n.www.protocol.http.HttpURLConnection  : sun.net.www.MessageHeader@274bae2c15 pairs: &#123;GET /nacos/v1/cs/configs?dataId=sentinel-sample-degrade-rules&amp;accessToken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTY1Mzg0Mjg1Mn0.wBkcBtauArpqcVIXlKKIuPPrTF92IV9hr0nYoW8oLf4&amp;group=SAMPLE_GROUP HTTP/<span class="number">1.1</span>: <span class="keyword">null</span>&#125;&#123;Content-Type: application/json&#125;&#123;Accept-Charset: UTF-<span class="number">8</span>&#125;&#123;Accept-Encoding: gzip&#125;&#123;Content-Encoding: gzip&#125;&#123;Client-AppName: unknown&#125;&#123;Client-RequestTS: <span class="number">1653824853054</span>&#125;&#123;Client-RequestToken: 6b7ac561c203a4f92077945e3d4ec548&#125;&#123;Client-Version: <span class="number">1.3</span><span class="number">.2</span>&#125;&#123;exConfigInfo: <span class="keyword">true</span>&#125;&#123;RequestId: 4e36abe0-1c50-<span class="number">4198</span>-8bfd-d12cca372c27&#125;&#123;User-Agent: Java/<span class="number">1.8</span><span class="number">.0_241</span>&#125;&#123;Host: <span class="number">192.168</span><span class="number">.157</span><span class="number">.130</span>:<span class="number">8848</span>&#125;&#123;Accept: text/html, image/gif, image/jpeg, *; q=<span class="number">.2</span>, *<span class="comment">/*; q=.2&#125;&#123;Connection: keep-alive&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><p><strong>第四步，在 Nacos 配置熔断规则。</strong><br>设置 data-id 为 sentinel-sample-degrade-rules，Groups 为 SAMPLE_GROUP与微服务的设置保持一致。</p><p><img src="/2022/05/28/2022-05-28Sentinel进阶应用场景/4.png" alt="配置文件分散在应用中" loading="lazy"></p><center>配置文件分散在应用中</center><p>配置内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>:<span class="string">&quot;createOrder&quot;</span>, #自定义资源名</span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span>:<span class="string">&quot;default&quot;</span>, #命名空间</span><br><span class="line">    <span class="attr">&quot;grade&quot;</span>:<span class="number">0</span>, #0-慢调用比例 1-异常比例 2-异常数</span><br><span class="line">    <span class="attr">&quot;count&quot;</span>:<span class="number">100</span>, #最大RT 100毫秒执行时间</span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span>:<span class="number">5</span>, #时间窗口5秒</span><br><span class="line">    <span class="attr">&quot;minRequestAmount&quot;</span>:<span class="number">1</span>, #最小请求数</span><br><span class="line">    <span class="attr">&quot;slowRatioThreshold&quot;</span>:<span class="number">0.1</span> #比例阈值</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>上面这段 JSON 完整的含义是：在过去 1 秒内，如果 createOrder资源被访问 1 次后便开启熔断检查，如果其中有 10% 的访问处理时间超过 100 毫秒，则触发熔断 5 秒钟，这期间访问该方法所有请求都将直接抛出 DegradeException，5 秒后该资源点回到“半开”状态等待新的访问，如果下一次访问处理成功，资源点恢复正常状态，如果下一次处理失败，则继续熔断 5 秒钟。</p><p><img src="/2022/05/28/2022-05-28Sentinel进阶应用场景/5.png" alt="熔断机制示意图" loading="lazy"></p><center>熔断机制示意图</center><p>设置成功，访问 Spring Boot Actuator<a class="link" href="http://localhost/actuator/sentinel">http://localhost/actuator/sentinel<i class="fas fa-external-link-alt"></i></a> ，可以看到此时 gradeRules 数组下 createOrder 资源点的熔断规则已被 Nacos推送并立即生效。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;appName&quot;</span>: <span class="string">&quot;sentinel-sample&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;consoleServer&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;r1&quot;</span>: <span class="string">&quot;192.168.157.133&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;r2&quot;</span>: <span class="number">9100</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;coldFactor&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;systemRules&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;authorityRule&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;paramFlowRule&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;flowRules&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;/test_flow_rule&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;grade&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;count&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">&quot;strategy&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;controlBehavior&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;warmUpPeriodSec&quot;</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="attr">&quot;maxQueueingTimeMs&quot;</span>: <span class="number">500</span>,</span><br><span class="line">                <span class="attr">&quot;clusterMode&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;degradeRules&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;metricsFileCharset&quot;</span>: <span class="string">&quot;UTF-8&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="number">-2147483648</span>,</span><br><span class="line">        <span class="attr">&quot;urlPatterns&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;/**&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;totalMetricsFileCount&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">&quot;datasource&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;degrade&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;nacos&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;dataType&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ruleType&quot;</span>: <span class="string">&quot;DEGRADE&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;serverAddr&quot;</span>: <span class="string">&quot;192.168.157.131:8848,192.168.157.130:8848,192.168.157.132:8848&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;groupId&quot;</span>: <span class="string">&quot;SAMPLE_GROUP&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;dataId&quot;</span>: <span class="string">&quot;sentinel-sample-degrade-rules&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;flow&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;nacos&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;dataType&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ruleType&quot;</span>: <span class="string">&quot;FLOW&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;serverAddr&quot;</span>: <span class="string">&quot;192.168.157.131:8848,192.168.157.130:8848,192.168.157.132:8848&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;groupId&quot;</span>: <span class="string">&quot;SAMPLE_GROUP&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;dataId&quot;</span>: <span class="string">&quot;sentinel-sample-flow-rules&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;clientIp&quot;</span>: <span class="string">&quot;192.168.157.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clientPort&quot;</span>: <span class="string">&quot;8719&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;logUsePid&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;metricsFileSize&quot;</span>: <span class="number">52428800</span>,</span><br><span class="line">    <span class="attr">&quot;logDir&quot;</span>: <span class="string">&quot;C:\\Users\\87762\\logs\\csp\\&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;heartbeatIntervalMs&quot;</span>: <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>自定义资源点熔断规则</center><p>下面咱们来验证下，因为规则允许最大时长为 100 毫秒，而在 createOrder 方法中模拟业务处理需要 101 毫秒，显然会触发熔断。</p><p>连续访问 <a class="link" href="http://localhost/test_degrade_rule">http://localhost/test_degrade_rule<i class="fas fa-external-link-alt"></i></a> ，当第二次访问时便会出现 500 错误。</p><h3 id="开发友好的异常处理程序"><a href="#开发友好的异常处理程序" class="headerlink" title="开发友好的异常处理程序"></a>开发友好的异常处理程序</h3><p>对于 Sentinel 的异常处理程序要区分为两种情况：</p><ul><li><p>针对 RESTful 接口的异常处理；</p></li><li><p>针对自定义资源点的异常处理。</p></li></ul><h4 id="针对-RESTful-接口的异常处理"><a href="#针对-RESTful-接口的异常处理" class="headerlink" title="针对 RESTful 接口的异常处理"></a>针对 RESTful 接口的异常处理</h4><p>默认情况下如果访问触发了流控规则，则会直接响应异常信息“BlockedbySentinel (flow limiting)”。</p><p>我们都知道，RESTful接口默认应返回 JSON 格式数据，如果直接返回纯文本，调用者将无法正确解析，所以咱们要对其进行封装提供更友好的 JSON 格式数据。</p><p>针对 RESTful 接口的统一异常处理需要实现 BlockExceptionHandler，我们先给出完整代码。</p><p>BlockExceptionHandler.handle() 方法第三个参数类型是 BlockException，它有五种子类代表不同类型的规则异常。</p><ol><li>FlowException：流控规则异常。</li><li>DegradeException：熔断规则异常。</li><li>ParamFlowException：热点参数规则异常。</li></ol><p>例如：针对 id=5 的冷门商品编号时不开启限流，针对 id=10 的热门商品编号则需要进行限流，当 10 号商品被限流时抛出热点参数异常。</p><ol start="4"><li>SystemBlockException：系统规则异常。</li></ol><p>例如：服务器 CPU 负载超过80%，抛出系统规则异常。</p><ol start="5"><li>AuthorityException：授权规则异常。</li></ol><p>例如：某个 IP 被列入黑名单，该 IP 在访问时就会抛出授权规则异常。</p><p>我们利用 instanceof关键字确定具体的规则异常后，便通过response 响应对象将封装好的 ResponseObject对象返回给应用前端，此时响应中 code 值不再为 0，而是对应的异常类型。</p><p>例如，当 RESTful触发流控规则后，前端响应如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="string">&quot;FlowException&quot;</span>,</span><br><span class="line">    message: <span class="string">&quot;接口已被限流&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当触发熔断规则后，前端响应如下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="string">&quot;DegradeException&quot;</span>,</span><br><span class="line">    message: <span class="string">&quot;接口已被熔断,请稍后再试&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种统一而通用的异常处理机制，对RESTful 屏蔽了sentinel-core默认的错误文本，让项目采用统一的 JSON 规范进行输出。</p><h4 id="自定义资源点的异常处理"><a href="#自定义资源点的异常处理" class="headerlink" title="自定义资源点的异常处理"></a>自定义资源点的异常处理</h4><p>自定义资源点的异常处理与 RESTful 接口处理略有不同，我们需要在 @SentinelResource 注解上额外附加 blockHandler属性进行异常处理，这里先给出完整代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示用的业务逻辑类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;createOrder&quot;,blockHandler = &quot;createOrderBlockHandler&quot;)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟创建订单业务</span></span><br><span class="line"><span class="comment">     * 抛出 IllegalStateException 异常用于模拟业务逻辑执行失败的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟处理业务逻辑需要 101 毫秒</span></span><br><span class="line">            Thread.sleep(<span class="number">101</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrderBlockHandler</span><span class="params">(BlockException e)</span> <span class="keyword">throws</span> IllegalStateException</span>&#123;</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> FlowException)&#123;<span class="comment">//限流异常</span></span><br><span class="line">            msg = <span class="string">&quot;资源已被限流&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> DegradeException)&#123;<span class="comment">//熔断异常</span></span><br><span class="line">            msg = <span class="string">&quot;资源已被熔断,请稍后再试&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ParamFlowException)&#123; <span class="comment">//热点参数限流</span></span><br><span class="line">            msg = <span class="string">&quot;热点参数限流&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> SystemBlockException)&#123; <span class="comment">//系统规则异常</span></span><br><span class="line">            msg = <span class="string">&quot;系统规则(负载/....不满足要求)&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> AuthorityException)&#123; <span class="comment">//授权规则异常</span></span><br><span class="line">            msg = <span class="string">&quot;授权规则不通过&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这份代码中可以清楚地看到以下两点变化。</p><p>第一，我们为 @SentinelResource 附加了 blockHandler 属性，这个属性指向 createOrderBlockHandler 方法名，它的作用是当 sentinel-core 触发规则异常后，自动执行 createOrderBlockHandler 方法进行异常处理。</p><p>第二，createOrderBlockHandler 方法的书写有两个要求：</p><ul><li><p>方法返回值、访问修饰符、抛出异常要与原始的 createOrder 方法完全相同。</p></li><li><p>createOrderBlockHandler 方法名允许自定义，但最后一个参数必须是 BlockException 对象，这是所有规则异常的父类，通过判断 BlockException 我们就知道触发了哪种规则异常。</p></li></ul><p>至于 createOrderBlockHandler 方法的代码和 RESTful 异常处理基本一致，先判断规则异常的种类再对外抛出 IllegalStateException异常。SampleController 会对 IllegalStateException 异常进行捕获，对外输出为 JSON 响应。</p><p>当程序运行后，咱们看一下结果。</p><p>访问 <a class="link" href="http://localhost/test_degrade_rule">http://localhost/test_degrade_rule<i class="fas fa-external-link-alt"></i></a> 当触发流控规则后，响应如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="string">&quot;IllegalStateException&quot;</span>,</span><br><span class="line">    message: <span class="string">&quot;资源已被限流&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当触发熔断规则后，响应如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="string">&quot;IllegalStateException&quot;</span>,</span><br><span class="line">    message: <span class="string">&quot;资源已被熔断,请稍后再试&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生产实践：Sentinel-进阶应用场景&quot;&gt;&lt;a href=&quot;#生产实践：Sentinel-进阶应用场景&quot; class=&quot;headerlink&quot; title=&quot;生产实践：Sentinel 进阶应用场景&quot;&gt;&lt;/a&gt;生产实践：Sentinel 进阶应用场景&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于Nacos集中管理应用配置</title>
    <link href="2022/05/22/2022-05-22%E5%9F%BA%E4%BA%8ENacos%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>2022/05/22/2022-05-22%E5%9F%BA%E4%BA%8ENacos%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2022-05-22T13:50:46.000Z</published>
    <updated>2022-07-06T06:01:56.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置中心：基于-Nacos-集中管理应用配置"><a href="#配置中心：基于-Nacos-集中管理应用配置" class="headerlink" title="配置中心：基于 Nacos 集中管理应用配置"></a>配置中心：基于 Nacos 集中管理应用配置</h1><p>构建 Nacos 配置中心正是 Sentinel 实现集群保护的基础所在，前面咱们在 Dashboard 配置的一系列规则都要在生产环境中基于 Nacos 配置中心进行持久化存储。</p><h2 id="为什么微服务架构必须部署配置中心"><a href="#为什么微服务架构必须部署配置中心" class="headerlink" title="为什么微服务架构必须部署配置中心"></a>为什么微服务架构必须部署配置中心</h2><p>现在微服务开发的主流技术是基于 Spring Boot 进行的，我们都知道 Spring Boot 默认配置文件为 application.yml 或者 application.properties。它保存了应用的主要配置信息，这些配置文件会随着应用发布被打包放入 Jar 文件，随着应用加载并运行。</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/1.png" alt="配置文件分散在应用中" loading="lazy"></p><center>配置文件分散在应用中</center><p>当我们的应用只有几个微服务时这些配置文件分散的存放在各个 Jar 中还没有问题。但是如果我们开发了大型互联网应用，涉及几十个研发团队、上百台服务器、上千个服务实例时，互联网的运维团队就要面对因为数量级增加带来的挑战了，总结下运维主要来自三个方面。</p><p>第一，纯粹的工作量增加。假设微服务 A 有 400 个实例，这些配置文件 application.yml 分散存储在每一个 Jar 中，此时因为机房环境变化，数据库服务器的 IP 变更，运维人员就不得不在 400 个实例中对每一个数据库连接 URL 进行调整，这个过程费时费力还容易出错。</p><p>第二，版本管理的需求。因为生产环境的状况远比开发、测试环境复杂，谁都无法保证新版本服务上线时新应用一定不会出问题。如果出现重大故障，生产环境下必须具备应用版本回滚的机制，保证生产可用的前提下再分析故障原因，而这个场景中如何对配置文件进行版本管理也是必须要考虑到的。</p><p>第三，多环境之间的切换。在成熟的软件研发流程中，是拥有多套不同环境的，例如：开发环境、测试环境、UAT 环境、仿真环境、生产环境。不同环境中各种组件的 IP、用户名、密码、配置项都会有差异，在不同环境下运行要求应用具备快速切换并加载对应的配置文件的能力，显然将配置写死在 Jar 中是无法满足这个要求的。</p><p>为了解决这些问题，在现有的微服务架构下，必须额外的引入“配置中心”这一组件，配置中心的职责就是集中管理微服务架构中每一个服务实例的配置数据。当微服务架构引入配置中心后，微服务应用只需持有应用启动的最小化配置，在应用启动时微服务应用所需的其他配置数据，诸如数据库连接字符串、各种用户名密码、IP 等信息均从配置中心远程下载，不再本地保存。同时，作为开发应用的程序员，在书写应用配置时也不再直接写入 application.yml 配置，而是直接在配置中心提供的 UI 进行设置。</p><p>当引入配置中心后，微服务的架构会产生如下变化。</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/2.png" alt="配置中心的作用" loading="lazy"></p><center>配置中心的作用</center><p>研发运维人员在配置中心提前定义各种环境的配置信息，之后在微服务实例启动时根据服务名、环境等从配置中心查询配置数据并下载到服务实例本地，最后服务实例加载这些来自配置中心的配置信息完成应用的启动。</p><p>说到这想必你对配置中心的作用已经了解，在 Spring Cloud Alibaba 这个架构下，Nacos 除了能作为注册中心，还提供了配置中心的功能。别看 Nacos 身兼多职，但每一项职责也并不平庸，Nacos 作为配置中心，除了基本的配置存储，还提供了版本管理、变更推送、监听查询以及友好的中文 UI 界面，无论是研发人员还是运维人员都可以快速上手实现应用配置。</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/3.png" alt="Nacos 动态配置服务" loading="lazy"></p><center>Nacos 动态配置服务</center><h2 id="部署-Nacos-配置中心与服务接入"><a href="#部署-Nacos-配置中心与服务接入" class="headerlink" title="部署 Nacos 配置中心与服务接入"></a>部署 Nacos 配置中心与服务接入</h2><h3 id="部署-Nacos-配置中心"><a href="#部署-Nacos-配置中心" class="headerlink" title="部署 Nacos 配置中心"></a>部署 Nacos 配置中心</h3><p>Nacos 本身就同时具备注册中心与配置中心职责，在部署方面与之前部署 Nacos 集群基本一致。</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/4.png" alt="配置列表页面" loading="lazy"></p><center>配置列表页面</center><h3 id="微服务接入-Nacos-配置中心"><a href="#微服务接入-Nacos-配置中心" class="headerlink" title="微服务接入 Nacos 配置中心"></a>微服务接入 Nacos 配置中心</h3><p>第一步，创建工程引入依赖。</p><p>利用 Spring Initializr 向导创建 order-service 订单服务工程，确保 pom.xml 引入以下 3 个依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot Web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Nacos注册中心starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Nacos配置中心starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，在工程创建配置文件。</p><p>在接入 Nacos 配置中心之前，要确保 Spring Boot 配置是完整的。application.yml 文件内容如下，注意最后两行，custom 开头的配置项是自定义的，等一下用于演示环境切换。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span> <span class="comment">#Nacos通信地址</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"><span class="attr">custom:</span> <span class="comment">#自定义配置项</span></span><br><span class="line">  <span class="attr">flag:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.31</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三步，创建演示代码。</p><p>新建 TestController，增加 /test 接口，将配置文件中两个自定义配置输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.flag&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String flag;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.database&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String database;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;flag:&quot;</span> + flag + <span class="string">&quot;&lt;br/&gt; database:&quot;</span> + database;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，启动应用查看结果。</p><p>打开浏览器，访问下面网址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8000/test</span></span><br><span class="line">结果如下：</span><br><span class="line"><span class="attr">flag</span>:development</span><br><span class="line"><span class="attr">database</span>:<span class="number">192.168</span><span class="number">.10</span><span class="number">.31</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 flag：development 说明当前是“开发环境”。<br>一切准备就绪，下面我们接入 Nacos 配置中心。</p><p>第一步，打开 Nacos 配置中心页面，新建配置。</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/5.png" alt="创建新的配置" loading="lazy"></p><center>创建新的配置</center><p>在新建配置页面包含六个选项：Data ID、Group、描述、说明、配置格式与配置内容</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/6.png" alt="创建新的配置" loading="lazy"></p><center>order-service-dev.yml 配置</center><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Nacos帮助文档: https://nacos.io/zh-cn/docs/concepts.html</span></span><br><span class="line">    <span class="comment"># Nacos认证信息</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.157</span><span class="number">.131</span><span class="string">:8848,192.168.157.130:8848,192.168.157.132:8848</span></span><br><span class="line">        <span class="comment"># 注册到 nacos 的指定 namespace，默认为 public</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">public</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">1024</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">warehouse-service:</span> <span class="comment">#服务提供者的微服务ID</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="comment">#设置对应的负载均衡类</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"></span><br><span class="line"><span class="attr">custom:</span></span><br><span class="line">  <span class="attr">flag:</span> <span class="string">DEVELOPMENT</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>Data ID</strong>：配置的唯一标识，格式固定为：{微服务id}-{环境名}.yml，这里填写 order-service-dev.yml，其中 dev 就是环境名代表这个配置文件是 order-service 的开发环境配置文件。</p></li><li><p><strong>Group</strong>：指定配置文件的分组，这里设置默认分组 DEFAULT_GROUP 即可。</p></li><li><p><strong>描述</strong>：说明 order-service-dev.yml 配置文件的用途。</p></li><li><p><strong>配置格式</strong>：指定“配置内容”的类型，这里选择 YAML 即可。</p></li><li><p><strong>配置内容</strong>：将 order-service 工程的 application.yml 文件内容粘贴过来。</p></li></ul><p>与此同时，在 nacos_config 数据库的 config_info 表中也出现了对应配置数据。</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/7.png" alt="config_info" loading="lazy"></p><center>config_info 表</center><p>第二步，回到 order-service 工程，删除 application.yml，因为这个文件内容已经保存在 Nacos 配置中心中了。</p><p>第三步，在 resources 目录下创建 bootstrap.yml 引导文件，对 Nacos 配置中心地址进行设置。注意，bootstrap.yml 文件名是固定的，不要随意改变。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-service</span> <span class="comment">#微服务id</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#环境名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="comment">#Nacos配置中心配置</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span> <span class="comment">#文件扩展名</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"><span class="attr">logging:</span> <span class="comment">#开启debug日志，仅为学习时使用</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>在上面的配置中，包含了两部分内容，第一部分说明 Nacos 配置中心的 IP 端口等信息，第二部分是通过文件中的 “微服务 id”-“环境名”.“文件扩展名” 三部分组合为有效的 data id，即order-service-dev.yml。</p><p><strong>这个 data id 要和 Nacos 的设置大小写保持完全一致</strong>，这样在微服务启动时便自动会从 Nacos配置中心获取 order-service-dev.yml 配置并下载到本地完成启动过程。</p><p>通过 Debug 日志发现，在启动时微服务向 Nacos 查询 order-service-dev.yml 的内容，并将配置内容打印在 Debug 级别日志中，之后作为应用配置加载完成启动。<br>访问 <a class="link" href="http://localhost:8000/test">http://localhost:8000/test<i class="fas fa-external-link-alt"></i></a> 运行结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag:development</span><br><span class="line"><span class="attr">database</span>:<span class="number">192.168</span><span class="number">.10</span><span class="number">.31</span></span><br></pre></td></tr></table></figure><p>到这里我们完成了 Nacos 配置中心的接入。这里做个小总结，因为我们把配置数据放在 Nacos 配置中心中，微服务在启动时自动进行下载，因此同一个微服务的所有实例得到的配置信息都是一致的，如果需要调整里面的配置，只需在 Nacos 中进行调整，然后让微服务实例重启即可重新下载生效。</p><p>说到这你肯定又联想到另一个问题，一旦配置变更就必须手动重启，那运维的效率还是太低，如果微服务能自动监听到配置变化自动加载新配置那岂不是更好。答案是肯定的，Nacos 通过主动推送方式允许程序在运行期间重新下载配置，下面我们就来介绍几个在生产中实用的配置技巧。</p><h2 id="Nacos-生产环境中的配置技巧"><a href="#Nacos-生产环境中的配置技巧" class="headerlink" title="Nacos 生产环境中的配置技巧"></a>Nacos 生产环境中的配置技巧</h2><h3 id="配置热加载技术"><a href="#配置热加载技术" class="headerlink" title="配置热加载技术"></a>配置热加载技术</h3><p>在 Nacos 中支持配置热加载，在运行过程中允许直接对新的配置项进行重新加载而不需要手动重启。首先咱们了解下热加载背后的处理机制。</p><p>Nacos 采用的是 Pull 拉取模式，但并不是简单的 Pull，而是一种长轮训机制。客户端采用长轮训的方式定时发起 Pull 请求，去检查服务端配置信息是否发生了变更，如果发生了变更，则客户端会根据变更的数据获得最新的配置。所谓的长轮训，是客户端发起轮训请求之后，服务端如果有配置发生变更，就直接返回。</p><p>如果客户端发起 Pull 请求后，发现服务端的配置和客户端的配置是保持一致的，那么服务端会先“Hold”住这个请求，也就是服务端拿到这个连接之后在指定的时间段内一直不返回结果，直到这段时间内配置发生变化，服务端会把原来“Hold”住的请求进行返回，如图所示：</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/8.png" alt="配置中心长轮询机制" loading="lazy"></p><center>Nacos 配置中心长轮询机制</center><p>Nacos 服务端收到请求之后，先检查配置是否发生了变更，如果没有，则设置一个定时任务，延期 29.5s 执行，并且把当前的客户端长轮询连接加入 allSubs 队列。这时候有两种方式触发该连接结果的返回：</p><ul><li><p>第一种是在等待 29.5s 后触发自动检查机制，这时候不管配置有没有发生变化，都会把结果返回客户端。而 29.5s 就是这个长连接保持的时间。</p></li><li><p>第二种是在 29.5s 内任意一个时刻，通过 Nacos Dashboard 或者 API 的方式对配置进行了修改，这会触发一个事件机制，监听到该事件的任务会遍历 allSubs 队列，找到发生变更的配置项对应的 ClientLongPolling 任务，将变更的数据通过该任务中的连接进行返回，就完成了一次“推送”操作。</p></li></ul><p>这样既能够保证客户端实时感知配置的变化，也降低了服务端的压力。其中，这个长连接的会话超时时间默认为 30s。</p><p>为了支持热加载，服务 A 的程序针对热加载需要作出如下变动：</p><p>第一，配置数据必须被封装到单独的配置 Bean 中；</p><p>第二，这个配置 Bean 需要被 @Configuration 与 @RefreshScope 两个注解描述。</p><p>下面我们通过实例讲解：<br>对原有 order-server 作出修改，将 flag 与 database 两个属性移到单独的配置 Bean，并加入 @Configuration 与 @RefreshScope 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.flag&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String flag;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.database&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String database;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(String flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDatabase</span><span class="params">(String database)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，@Configuration 说明当前 Bean 是一个配置 Bean。是 Spring Boot 自带的 Java Config 注解。而 @RefreshScope 则用于监听，当 Nacos 推送新的配置后，由这个注解负责接收并为属性重新赋值。</p><p>此外，原有的 TestController 代码变更为引用 CustomConfig 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomConfig customConfig;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;flag:&quot;</span> + customConfig.getFlag() + <span class="string">&quot;&lt;br/&gt; database:&quot;</span> + customConfig.getDatabase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动应用后，咱们在 Nacos 手动改变配置信息</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/9.png" alt="配置变更对比" loading="lazy"></p><center>配置变更对比</center><p>确认发布后，在 order-service 服务的日志立即产生重新加载的信息，提示“Refresh Nacos config”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2022-05-28 01:06:17.673  INFO 16368 --- [68.157.132_8848] o.s.c.e.event.RefreshEventListener       : Refresh keys changed: [custom.flag]</span><br><span class="line"></span><br><span class="line">2022-05-28 01:06:17.673 DEBUG 16368 --- [68.157.132_8848] c.a.c.n.refresh.NacosContextRefresher    : Refresh Nacos config group=DEFAULT_GROUP,dataId=order-service-dev.yml,configInfo=# 应用名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下，新的配置已即时生效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag:<span class="literal">true</span></span><br><span class="line"><span class="attr">database</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切换环境配置文件"><a href="#切换环境配置文件" class="headerlink" title="切换环境配置文件"></a>切换环境配置文件</h3><p>假如产品开发完成准备投产，便可利用 Nacos 提供的环境配置迅速完成从开发到生产环境的切换，来看我演示。</p><p>第一步，在 Nacos 中设置生产环境的配置，Data Id 为 order-service-prd.yml，其中 prd 是 production 的缩写，代表生产环境配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">10.181</span><span class="number">.36</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"><span class="attr">custom:</span> <span class="comment">#自定义配置项</span></span><br><span class="line">  <span class="attr">flag:</span> <span class="string">production</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">10.181</span><span class="number">.36</span><span class="number">.22</span></span><br></pre></td></tr></table></figure><p>第二步，调整 order-service 的 bootstrap.yml 引导文件，最重要的地方是修改环境名为 prd，同时更换为生产环境 Nacos 的通信地址，打包后发布。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-service</span> <span class="comment">#微服务id</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prd</span> <span class="comment">#环境名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="comment">#这里配置的是Nacos配置中心</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span> <span class="comment">#指定文件扩展名</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.157</span><span class="number">.131</span><span class="string">:8848,192.168.157.130:8848,192.168.157.132:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure><p>访问<a class="link" href="http://localhsot:8081/test">http://localhsot:8081/test<i class="fas fa-external-link-alt"></i></a><br>运行结果如下，这里看到 flag:production 说明已切换到生产环境。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag:DEVELOPMENT </span><br><span class="line"><span class="attr">database</span>:<span class="number">10.181</span><span class="number">.36</span><span class="number">.22</span></span><br></pre></td></tr></table></figure><h3 id="管理基础配置数据"><a href="#管理基础配置数据" class="headerlink" title="管理基础配置数据"></a>管理基础配置数据</h3><p>对比 order-service-dev.yml 与 order-service-prd.yml 发现，在不同环境的配置文件中普遍存在固定的配置项，例如：spring.application.name=order-service 配置项就是稳定的，且修改它会影响所有环境配置文件。对于这种基础的全局配置，我们可以将其存放到单独的 order-service.yml 配置中，在 order-service 服务启动时，这个不带环境名的配置文件必然会被加载。</p><p><img src="/2022/05/22/2022-05-22基于Nacos集中管理应用配置/10.png" alt="order-service.yml" loading="lazy"></p><center>order-service.yml 包含基础配置</center><p>order-service-dev.yml 只包含与开发环境的相关配置。</p><p>order-service-prd.yml 只包含与生产环境的相关配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置中心：基于-Nacos-集中管理应用配置&quot;&gt;&lt;a href=&quot;#配置中心：基于-Nacos-集中管理应用配置&quot; class=&quot;headerlink&quot; title=&quot;配置中心：基于 Nacos 集中管理应用配置&quot;&gt;&lt;/a&gt;配置中心：基于 Nacos 集中管理应用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务架构雪崩效应与服务限流</title>
    <link href="2022/05/21/2022-05-21%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81/"/>
    <id>2022/05/21/2022-05-21%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81/</id>
    <published>2022-05-21T13:52:11.000Z</published>
    <updated>2022-05-22T13:46:13.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统保护：微服务架构雪崩效应与服务限流"><a href="#系统保护：微服务架构雪崩效应与服务限流" class="headerlink" title="系统保护：微服务架构雪崩效应与服务限流"></a>系统保护：微服务架构雪崩效应与服务限流</h1><h2 id="微服务的雪崩效应"><a href="#微服务的雪崩效应" class="headerlink" title="微服务的雪崩效应"></a>微服务的雪崩效应</h2><p>“雪崩”一词指的是山地积雪由于底部溶解等原因造成的突然大块塌落的现象，具有很强的破坏力。在微服务项目中指由于突发流量导致某个服务不可用，从而导致上游服务不可用，并产生级联效应，最终导致整个系统不可用，使用雪崩这个词来形容这一现象最合适不过。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/1.png" alt="服务雪崩" loading="lazy"></p><center>一次线上的服务雪崩事故</center><h3 id="为什么微服务会产生雪崩效应"><a href="#为什么微服务会产生雪崩效应" class="headerlink" title="为什么微服务会产生雪崩效应"></a>为什么微服务会产生雪崩效应</h3><p>如下图所示，假如我们开发了一套分布式应用系统，前端应用分别向 A/H/I/P 四个服务发起调用请求：<br><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/2.png" alt="前端应用需要四个服务" loading="lazy"></p><center>前端应用需要四个服务</center><p>但随着时间推移，假如服务 I 因为优化问题，导致需要 20 秒才能返回响应，这就必然会导致 20 秒内该请求线程会一直处于阻塞状态</p><p>但是，如果这种状况放在高并发场景下，就绝对不允许出现，假如在 20 秒内有 10 万个请求通过应用访问到后端微服务。容器会因为大量请求阻塞积压导致连接池爆满，而这种情况后果极其严重！轻则“服务无响应”，重则前端应用直接崩溃。</p><p>以上这种因为某一个节点长时间处理导致应用请求积压崩溃的现象被称为微服务的“雪崩效应”。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/3.png" alt="大量线程积压" loading="lazy"></p><center>当大量线程积压后，前端应用崩溃，雪崩效应产生</center><h3 id="如何有效避免雪崩效应？"><a href="#如何有效避免雪崩效应？" class="headerlink" title="如何有效避免雪崩效应？"></a>如何有效避免雪崩效应？</h3><p>刚才我们分析了雪崩效应是因为出现瞬间大流量+微服务响应慢造成的。针对这两点在架构设计时要采用不同方案。</p><ol><li><p>采用限流方式进行预防：可以采用限流方案，控制请求的流入，让流量有序的进入应用，保证流量在一个可控的范围内。</p></li><li><p>采用服务降级与熔断进行补救：针对响应慢问题，可以采用服务降级与熔断进行补救。服务降级是指当应用处理时间超过规定上限后，无论服务是否处理完成，便立即触发服务降级，响应返回预先设置的异常信息。</p></li></ol><h2 id="Alibaba-Sentinel"><a href="#Alibaba-Sentinel" class="headerlink" title="Alibaba Sentinel"></a>Alibaba Sentinel</h2><p>在 Spring Cloud Alibaba 生态中有一个重要的流控组件 Sentinel。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><h3 id="Sentinel-具有以下特征。"><a href="#Sentinel-具有以下特征。" class="headerlink" title="Sentinel 具有以下特征。"></a>Sentinel 具有以下特征。</h3><ul><li><p><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p></li><li><p><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p></li><li><p><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其他开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 整合只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p></li><li><p><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p></li></ul><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/4.png" alt="Alibaba Sentinel特性图" loading="lazy"></p><center>Alibaba Sentinel特性图</center><h3 id="Sentinel-配置入门"><a href="#Sentinel-配置入门" class="headerlink" title="Sentinel 配置入门"></a>Sentinel 配置入门</h3><p>Sentinel 分为两个部分：Sentinel Dashboard和Sentinel 客户端。</p><ul><li><p><strong>Sentinel Dashboard</strong>：Sentinel Dashboard 是 Sentinel 配套的可视化控制台与监控仪表盘套件，它支持节点发现，以及健康情况管理、监控（单机和集群）、规则管理和推送的功能。Sentinel Dashboard 是基于 Spring Boot 开发的 WEB 应用，打包后可以直接运行。</p></li><li><p><strong>Sentinel 客户端</strong>：Sentinel 客户端需要集成在 Spring Boot 微服务应用中，用于接收来自 Dashboard 配置的各种规则，并通过 Spring MVC Interceptor 拦截器技术实现应用限流、熔断保护。</p></li></ul><h3 id="部署-Sentinel-Dashboard（仪表盘）"><a href="#部署-Sentinel-Dashboard（仪表盘）" class="headerlink" title="部署 Sentinel Dashboard（仪表盘）"></a>部署 Sentinel Dashboard（仪表盘）</h3><ol><li><p>访问：<a class="link" href="https://github.com/alibaba/Sentinel/releases%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88">https://github.com/alibaba/Sentinel/releases，下载最新版<i class="fas fa-external-link-alt"></i></a> Sentinel Dashboard。</p></li><li><p>利用下面的命令启动 Dashboard。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Dserver.port=<span class="number">9100</span> sentinel-dashboard-<span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>.jar</span><br></pre></td></tr></table></figure></li></ol><p>这个命令的含义是启动 Sentinel Dashboard 应用，Sentinel Dashboard 会监听9100端口实现与微服务的通信。同时我们可以访问下面的网址查看 Sentinel Dashboard 的UI界面。<br><a class="link" href="http://192.168.31.10:9100/">http://192.168.31.10:9100<i class="fas fa-external-link-alt"></i></a></p><p>在用户名、密码处输入 sentinel/sentinel，便可进入 Dashboard。</p><h3 id="微服务内置-Sentinel-客户端"><a href="#微服务内置-Sentinel-客户端" class="headerlink" title="微服务内置 Sentinel 客户端"></a>微服务内置 Sentinel 客户端</h3><p>第一步，利用 Spring Initializr 向导创建 sentinel-sample 工程，pom.xml 增加以下三项依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Nacos客户端Starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Sentinel客户端Starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对外暴露Spring Boot监控指标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，配置 Nacos 与 Sentinel 客户端。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-sample</span> <span class="comment">#应用名&amp;微服务id</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span> <span class="comment">#Sentinel Dashboard通信地址</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:9100</span></span><br><span class="line">      <span class="attr">eager:</span> <span class="literal">true</span> <span class="comment">#取消控制台懒加载</span></span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment">#Nacos通信地址</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span> <span class="comment">#将所有可用的监控指标项对外暴露</span></span><br><span class="line">      <span class="attr">exposure:</span> <span class="comment">#可以访问 /actuator/sentinel进行查看Sentinel监控项</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>第三步，验证配置。</p><p>在 Sentinel Dashboard 左侧看到 sentinel-sample 服务出现，则代表 Sentinel 客户端与 Dashboard 已经完成通信。<br><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/5.png" alt="Sentinel Dashboard" loading="lazy"></p><h3 id="配置限流规则"><a href="#配置限流规则" class="headerlink" title="配置限流规则"></a>配置限流规则</h3><p>第一步，在 sentinel-sample 服务中，增加 SentinelSampleController 类，用于演示 Sentinel 限流规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelSampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test_flow_rule&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFlowRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 sentinel-sample，访问<a class="link" href="http://localhost/test_flow_rule%EF%BC%8C%E6%97%A0%E8%AE%BA%E5%88%B7%E6%96%B0%E5%A4%9A%E5%B0%91%E6%AC%A1%EF%BC%8C%E9%83%BD%E4%BC%9A%E7%9C%8B%E5%88%B0%E2%80%9CSUCCESS%E2%80%9D%E3%80%82">http://localhost/test_flow_rule，无论刷新多少次，都会看到“SUCCESS”。<i class="fas fa-external-link-alt"></i></a></p><p>第二步，访问 Sentinel Dashboard 配置限流规则。<br>在左侧找到簇点链路，右侧定位到 /test_flow_rule，点击后面的“流控”按钮。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/6.png" alt="配置限流规则" loading="lazy"></p><p>在弹出界面，按下图配置，其含义为 /test_flow_rule 接口每秒钟只允许 1QPS 访问，超出的请求直接服务降级返回异常。最后点击“新增”完成规则设置。</p><p>第三步，验证流控效果。</p><p>重新访问<a class="link" href="http://localhost/test_flow_rule%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%8D%E5%A4%8D%E5%88%B7%E6%96%B0%E3%80%82">http://localhost/test_flow_rule，浏览器反复刷新。<i class="fas fa-external-link-alt"></i></a></p><p>第一次刷新时会出现“SUCCESS”文本代表处理成功。</p><p>同一秒内再次刷新便会出现 “Blocked by Sentinel (flow limiting)”，代表服务已被限流降级。<br><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/7.png" alt="服务已被限流降级" loading="lazy"></p><h3 id="Sentinel-Dashboard通信与降级原理"><a href="#Sentinel-Dashboard通信与降级原理" class="headerlink" title="Sentinel Dashboard通信与降级原理"></a>Sentinel Dashboard通信与降级原理</h3><p>Sentinel Dashboard 是Sentinel的控制端，是新的限流与熔断规则的创建者。当内置在微服务内的 Sentinel Core（客户端）接收到新的限流、熔断规则后，微服务便会自动启用的相应的保护措施。</p><p>按执行流程，Sentinel 的执行流程分为三个阶段：</p><ol><li><p>Sentinel Core 与 Sentinel Dashboard 建立连接；</p></li><li><p>Sentinel Dashboard 向 Sentinel Core 下发新的保护规则；</p></li><li><p>Sentinel Core 应用新的保护规则，实施限流、熔断等动作。</p></li></ol><h4 id="第一步，建立连接。"><a href="#第一步，建立连接。" class="headerlink" title="第一步，建立连接。"></a>第一步，建立连接。</h4><p>Sentine Core 在初始化的时候，通过 application.yml 参数中指定的 Dashboard 的 IP地址，会主动向 dashboard 发起连接的请求。</p><p>该请求是以心跳包的方式定时向 Dashboard 发送，包含 Sentinel Core 的 AppName、IP、端口信息。这里有个重要细节：Sentinel Core为了能够持续接收到来自 Dashboard的数据，会在微服务实例设备上监听 8719 端口，在心跳包上报时也是上报这个 8719 端口，而非微服务本身的 80 端口。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/8.png" alt="Sentinel Core 向 Dashboard 建立连接" loading="lazy"></p><center>Sentinel Core 向 Dashboard 建立连接</center><h4 id="第二步，推送新规则。"><a href="#第二步，推送新规则。" class="headerlink" title="第二步，推送新规则。"></a>第二步，推送新规则。</h4><p>如果在 Dashboard 页面中设置了新的保护规则，会先从当前的 MachineInfo 中提取符合要求的微服务实例信息，之后通过 Dashboard内置的 transport 模块将新规则打包推送到微服务实例的 Sentinel Core，Sentinel Core收 到新规则在微服务应用中对本地规则进行更新，这些新规则会保存在微服务实例的 JVM 内存中。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/9.png" alt="Sentinel Dashboard 向Sentinel Core推送新规则" loading="lazy"></p><center>Sentinel Dashboard 向Sentinel Core推送新规则</center><h4 id="第三步，处理请求。"><a href="#第三步，处理请求。" class="headerlink" title="第三步，处理请求。"></a>第三步，处理请求。</h4><p>Sentinel Core 为服务限流、熔断提供了核心拦截器 SentinelWebInterceptor，这个拦截器默认对所有请求 /** 进行拦截，然后开始请求的链式处理流程，在对于每一个处理请求的节点被称为 Slot（槽），通过多个槽的连接形成处理链，在请求的流转过程中，如果有任何一个 Slot 验证未通过，都会产生 BlockException，请求处理链便会中断，并返回“Blocked by sentinel” 异常信息。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/10.png" alt="SentinelWebInterceptor 实施请求拦截与保护" loading="lazy"></p><center>SentinelWebInterceptor 实施请求拦截与保护</center><p>那这些 Slot 都有什么作用呢？我们需要了解一下，默认 Slot 有7 个，前 3 个 Slot为前置处理，用于收集、统计、分析必要的数据；后 4 个为规则校验 Slot，从Dashboard 推送的新规则保存在“规则池”中，然后对应 Slot 进行读取并校验当前请求是否允许放行，允许放行则送入下一个 Slot 直到最终被 RestController 进行业务处理，不允许放行则直接抛出 BlockException 返回响应。</p><p>以下是每一个 Slot 的具体职责：</p><ul><li><p>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</p></li><li><p>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT（运行时间）, QPS, thread count（线程总数）等，这些信息将用作为多维度限流，降级的依据；</p></li><li><p>StatistcSlot 则用于记录，统计不同维度的runtime 信息；</p></li><li><p>SystemSlot 则通过系统的状态，例如CPU、内存的情况，来控制总的入口流量；</p></li><li><p>AuthoritySlot 则根据黑白名单，来做黑白名单控制；</p></li><li><p>FlowSlot 则用于根据预设的限流规则，以及前面 slot 统计的状态，来进行限流；</p></li><li><p>DegradeSlot 则通过统计信息，以及预设的规则，来做熔断降级。</p></li></ul><h3 id="Sentinel-限流降级的规则配置"><a href="#Sentinel-限流降级的规则配置" class="headerlink" title="Sentinel 限流降级的规则配置"></a>Sentinel 限流降级的规则配置</h3><h4 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h4><p>实现限流降级的核心是如何统计单位时间某个接口的访问量，常见的算法有计数器算法、令牌桶算法、漏桶算法、滑动窗口算法。Sentinel 采用滑动窗口算法来统计访问量。</p><p>滑动窗口算法并不复杂，咱们举例说明：某应用限流控制 1 分钟最多允许 600 次访问。采用滑动窗口算法是将每 1 分钟拆分为 6（变量）个等份时间段，每个时间段为 10 秒，6 个时间段为 1 组在下图用红色边框区域标出，而这个红色边框区域就是滑动窗口。当每产生 1 个访问在对应时间段的计数器自增加 1，当滑动窗口内所有时间段的计数器总和超过 600，后面新的访问将被限流直接拒绝。同时每过 10 秒，滑动窗口向右移动，前面的过期时间段计数器将被作废。</p><p>总结下，滑动窗口算法的理念是将整段时间均分后独立计数再汇总统计，滑动窗口算法被广泛应用在各种流控场景中，请你理解它的实现过程。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/11.png" alt="SentinelWebInterceptor 实施请求拦截与保护" loading="lazy"></p><center>滑动窗口算法</center><h4 id="基于-Sentinel-Dashboard-的限流设置"><a href="#基于-Sentinel-Dashboard-的限流设置" class="headerlink" title="基于 Sentinel Dashboard 的限流设置"></a>基于 Sentinel Dashboard 的限流设置</h4><p>在 Sentinel Dashboard 中“簇点链路”,找到需要限流的 URI，点击“+流控”进入流控设置。小提示，sentinel-dashboard 基于懒加载模式，如果在簇点链路没有找到对应的 URI，需要先访问下这个功能的功能后对应的 URI 便会出现。<br><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/12.png" alt="流控设置界面" loading="lazy"></p><center>流控设置界面</center><p>流控规则项目说明主要有以下几点。</p><ul><li><p><strong>资源名</strong>：要流控的 URI，在 Sentinel 中 URI 被称为“资源”；</p></li><li><p><strong>针对来源</strong>：默认 default 代表所有来源，可以针对某个微服务或者调用者单独设置；</p></li><li><p><strong>阈值类型</strong>：是按每秒访问数量（QPS）还是并发数（线程数）进行流控；</p></li><li><p><strong>单机阈值</strong>：具体限流的数值是多少。</p></li></ul><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/13.png" alt="默认流控规则" loading="lazy"></p><center></center><p>点击对话框中的“高级选项”，就会出现更为详细的设置项。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/14.png" alt="高级选项" loading="lazy"></p><p>其中流控模式是指采用什么方式进行流量控制。Sentinel支持三种模式：直接、关联、链路，下面咱们分别讲解这三种模式。</p><ul><li><strong>直接模式：</strong></li></ul><p>以下图为例，当 List 接口 QPS 超过 1个时限流，浏览器会出现“Blocked by Sentinel”。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/15.png" alt="直接模式" loading="lazy"></p><center>流控模式-直接</center><ul><li><strong>关联模式：</strong></li></ul><p>如下图所示，当同 List 接口关联的update 接口 QPS 超过 1 时，再次访问List 接口便会响应“Blocked by Sentinel”。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/16.png" alt="关联模式" loading="lazy"></p><center>流控模式-关联</center><ul><li><strong>链路模式：</strong></li></ul><p>链路模式相对复杂，我们举例说明，现在某公司开发了一个单机的电商系统，为了满足完成“下订单”的业务，程序代码会依次执行订单创建方法-&gt;减少库存方法-&gt;微信支付方法-&gt;短信发送方法。方法像链条一样从前向后依次执行，这种执行的链条被称为调用链路，而链路模式限流就是为此而生。</p><p>以下图为例，在某个微服务中 List 接口，会被 Check 接口调用。在另一个业务，List 接口也会被 Scan 接口调用。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/17.png" alt="调用链路" loading="lazy"></p><center>调用链路</center><p>但如果按下图配置，将入口资源设为“/check”，则只会针对 check 接口的调用链路生效。当访问 check 接口的QPS 超过 1 时，List 接口就会被限流。而另一条链路从 scan 接口到List 接口的链路则不会受到任何影响。链路模式与关联模式最大的区别是 check 接口与 List 接口必须是在同一个调用链路中才会限流，而关联模式是任意两个资源只要设置关联就可以进行限流。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/18.png" alt="调用链路" loading="lazy"></p><center>流控模式-链路</center><p>流控效果有三种：<strong>快速失败</strong>、<strong>Warm UP（预热）</strong>、<strong>排队等待</strong>。</p><h5 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a><strong>快速失败</strong></h5><p>快速失败是指流浪当过限流阈值后，直接返回响应并抛出 BlockException，快速失败是最常用的处理形式。如下图所示，当 List 接口每秒 QPS 超过 1 时，可以直接抛出“Blocked By Sentinel”异常。</p><h5 id="Warm-Up（预热"><a href="#Warm-Up（预热" class="headerlink" title="Warm Up（预热"></a><strong>Warm Up（预热</strong></h5><p>Warm Up 用于应对瞬时大并发流量冲击。当遇到突发大流量 Warm Up 会缓慢拉升阈值限制，预防系统瞬时崩溃，这期间超出阈值的访问处于队列等待状态，并不会立即抛出 BlockException。</p><p>如下图所示，List 接口平时单机阈值 QPS 处于低水位：默认为 1000/3 (冷加载因子)≈333，当瞬时大流量进来，10 秒钟内将 QPS 阈值逐渐拉升至 1000，为系统留出缓冲时间，预防突发性系统崩溃。<br><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/19.png" alt="流控效果-Warm Up" loading="lazy"></p><center>流控效果-Warm Up</center><h5 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a><strong>排队等待</strong></h5><p>排队等待是采用匀速放行的方式对请求进行处理。如下所示，假设现在有100个请求瞬间进入，那么会出现以下几种情况：</p><ol><li><p>单机 QPS 阈值=1，代表每 1 秒只能放行 1 个请求，其他请求队列等待，共需 100 秒处理完毕；</p></li><li><p>单机 QPS 阈值=4，代表 250 毫秒匀速放行 1 个请求，其他请求队列等待，共需 25 秒处理完毕；</p></li><li><p>单机 QPS 阈值=200，代表 5 毫秒匀速放行一个请求，其他请求队列等待，共需 0.5 秒处理完毕；</p></li><li><p>如果某一个请求在队列中处于等待状态超过 2000 毫秒，则直接抛出 BlockException。</p></li></ol><p>注意，匀速队列只支持 QPS 模式，且单机阈值不得大于 1000。</p><h3 id="Sentinel-熔断降级的规则配置"><a href="#Sentinel-熔断降级的规则配置" class="headerlink" title="Sentinel 熔断降级的规则配置"></a>Sentinel 熔断降级的规则配置</h3><h4 id="什么是熔断？"><a href="#什么是熔断？" class="headerlink" title="什么是熔断？"></a>什么是熔断？</h4><p>先说现实中的股市熔断机制。2016 年 1 月 4 日，A 股遇到史上首次熔断，沪指开盘后跌幅超过 5%，直接引发熔断。三家股市交易所暂停交易15分钟，但恢复交易之后股市继续下跌，三大股市交易所暂停交易至闭市。通过现象可以看出熔断是一种保护机制，当事物的状态达到某种“不可接受”的情况时，便会触发“熔断”。在股市中，熔断条件就是大盘跌幅超过 5%，而熔断的措施便是强制停止交易 15 分钟，之后尝试恢复交易，如仍出现继续下跌，便会再次触发熔断直接闭市。但假设 15分钟后，大盘出现回涨，便认为事故解除继续正常交易。这是现实生活中的熔断，如果放在软件中也是一样的。</p><p>微服务的熔断是指在某个服务接口在执行过程中频繁出现故障的情况，我们便认为这种状态是“不可接受”的，立即对当前接口实施熔断。在规定的时间内，所有送达该接口的请求都将直接抛出 BlockException，在熔断期过后新的请求进入看接口是否恢复正常，恢复正常则继续运行，仍出现故障则再次熔断一段时间，以此往复直到服务接口恢复。</p><p>下图清晰的说明了 Sentinel的熔断过程：</p><ol><li>设置熔断的触发条件，当某接口超过20%的请求访问出现故障，便启动熔断；</li><li>在熔断状态下，若干秒内所有该接口的请求访问都会直接抛出BlockException拒绝访问。</li><li>熔断器过后，下一次请求重新访问接口，当前接口为“半开状态”，后续处理以下分两种情况。<br>&nbsp;- 当前请求被有效处理，接口恢复到正常状态。<br>&nbsp;- 当前请求访问出现故障，接口继续熔断。</li></ol><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/20.png" alt="Sentinel 熔断机制" loading="lazy"></p><center>Sentinel 熔断机制</center><h4 id="基于SentinelDashboard的熔断设置"><a href="#基于SentinelDashboard的熔断设置" class="headerlink" title="基于SentinelDashboard的熔断设置"></a>基于SentinelDashboard的熔断设置</h4><p>Sentinel Dashboard可以设置三种不同的熔断模式：慢调用比例、异常比例、异常数，下面我们分别讲解：</p><h5 id="慢调用比例"><a href="#慢调用比例" class="headerlink" title="慢调用比例"></a>慢调用比例</h5><p>慢调用比例是指当接口在1秒内“慢处理”数量超过一定比例，则触发熔断。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/21.png" alt="熔断模式-慢调用比例" loading="lazy"></p><center>熔断模式-慢调用比例</center><p>结合上图的设置，介绍下“慢调用比例”熔断规则。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/22.png" alt="慢调用比例" loading="lazy"></p><h5 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h5><p>异常比例是指 1 秒内按接口调用产生异常的比例（异常调用数/总数量）触发熔断。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/23.png" alt="熔断模式-异常比例" loading="lazy"></p><center>熔断模式-异常比例</center><p>结合上图的设置，介绍下“异常比例”熔断规则。<br><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/24.png" alt="异常比例" loading="lazy"></p><h5 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h5><p>异常数是指在 1 分钟内异常的数量超过阈值则触发熔断。</p><p><img src="/2022/05/21/2022-05-21微服务架构雪崩效应与服务限流/25.png" alt="熔断模式-异常数" loading="lazy"></p><center>熔断模式-异常数</center>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统保护：微服务架构雪崩效应与服务限流&quot;&gt;&lt;a href=&quot;#系统保护：微服务架构雪崩效应与服务限流&quot; class=&quot;headerlink&quot; title=&quot;系统保护：微服务架构雪崩效应与服务限流&quot;&gt;&lt;/a&gt;系统保护：微服务架构雪崩效应与服务限流&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway 如何把好微服务的大门</title>
    <link href="2022/05/20/2022-05-20SpringCloudGateway%E5%A6%82%E4%BD%95%E6%8A%8A%E5%A5%BD%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%A4%A7%E9%97%A8/"/>
    <id>2022/05/20/2022-05-20SpringCloudGateway%E5%A6%82%E4%BD%95%E6%8A%8A%E5%A5%BD%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%A4%A7%E9%97%A8/</id>
    <published>2022-05-20T06:17:04.000Z</published>
    <updated>2022-05-21T10:10:49.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务门户：Spring-Cloud-Gateway-如何把好微服务的大门"><a href="#服务门户：Spring-Cloud-Gateway-如何把好微服务的大门" class="headerlink" title="服务门户：Spring Cloud Gateway 如何把好微服务的大门"></a>服务门户：Spring Cloud Gateway 如何把好微服务的大门</h1><h2 id="API-网关的作用"><a href="#API-网关的作用" class="headerlink" title="API 网关的作用"></a>API 网关的作用</h2><p>如下图所示，对于整个微服务来说如果将每一个微服务的接口直接暴露给用户是错误的做法，这里主要体现出三个问题：</p><ul><li><p>服务将所有 API 接口对外直接暴露给用户端，这本身就是不安全和不可控的，用户可能越权访问不属于它的功能，例如普通的用户去访问管理员的高级功能。</p></li><li><p>后台服务可能采用不同的通信方式，如服务 A 采用 RESTful 通信，服务 B 采用 RPC 通信，不同的接入方式让用户端接入困难。尤其是 App 端接入 RPC 过程更为复杂。</p></li><li><p>在服务访问前很难做到统一的前置处理，如服务访问前需要对用户进行鉴权，这就必须将鉴权代码分散到每个服务模块中，随着服务数量增加代码将难以维护。</p></li></ul><p><img src="/2022/05/20/2022-05-20SpringCloudGateway如何把好微服务的大门/1.png" alt="用户端直接访问微服务" loading="lazy"></p><center>用户端直接访问微服务</center><p>为了解决以上问题，API 网关应运而生，加入网关后应用架构变为下图所示。</p><p><img src="/2022/05/20/2022-05-20SpringCloudGateway如何把好微服务的大门/2.png" alt="引入API网关后的微服务架构" loading="lazy"></p><center>引入 API 网关后的微服务架构</center><p>当引入 API 网关后，在用户端与微服务之间建立了一道屏障，通过 API 网关为微服务访问提供了统一的访问入口，所有用户端的请求被 API 网关拦截并在此基础上可以实现额外功能，例如：</p><ul><li><p>针对所有请求进行统一鉴权、熔断、限流、日志等前置处理，让微服务专注自己的业务。</p></li><li><p>统一调用风格，通常 API 网关对外提供 RESTful 风格 URL 接口。用户传入请求后，由 API 网关负责转换为后端服务需要的 RESTful、RPC、WebService 等方式，这样便大幅度简化用户的接入难度。</p></li><li><p>更好的安全性，在通过 API 网关鉴权后，可以控制不同角色用户访问后端服务的权利，实现了服务更细粒度的权限控制。</p></li><li><p>API 网关是用户端访问 API 的唯一入口，从用户的角度来说只需关注 API 网关暴露哪些接口，至于后端服务的处理细节，用户是不需要知道的。从这方面讲，微服务架构通过引入 API 网关，将用户端与微服务的具体实现进行了解耦。</p></li></ul><h2 id="讲解-Spring-Cloud-Gateway-的配置技巧"><a href="#讲解-Spring-Cloud-Gateway-的配置技巧" class="headerlink" title="讲解 Spring Cloud Gateway 的配置技巧"></a>讲解 Spring Cloud Gateway 的配置技巧</h2><h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><p>基于NIO异步处理，抛弃了Zuul基于Servlet同步通信的设计，有更好的性能，更简单实用的配置</p><p>以下是 Spring Cloud Gateway 的关键特征：</p><ul><li>基于 JDK 8+ 开发；</li><li>基于 Spring Framework 5 + Project Reactor + Spring Boot 2.0 构建；</li><li>支持动态路由，能够匹配任何请求属性上的路由；</li><li>支持基于 HTTP 请求的路由匹配（Path、Method、Header、Host 等）；</li><li>过滤器可以修改 HTTP 请求和 HTTP 响应（增加/修改 Header、增加/修改请求参数、改写请求 Path 等等）；</li><li>…</li></ul><h3 id="Spring-Cloud-Gateway使用入门"><a href="#Spring-Cloud-Gateway使用入门" class="headerlink" title="Spring Cloud Gateway使用入门"></a>Spring Cloud Gateway使用入门</h3><p>示例说明：</p><p>假设“service-a”微服务提供了三个 RESTful 接口。<br><img src="/2022/05/20/2022-05-20SpringCloudGateway如何把好微服务的大门/3.png" alt="service-a" loading="lazy"></p><p>假设 “service-b” 微服务提供了三个 RESTful 接口。<br><img src="/2022/05/20/2022-05-20SpringCloudGateway如何把好微服务的大门/4.png" alt="service-b" loading="lazy"></p><p>如何通过部署 Spring Cloud Gateway 实现 API 路由功能来屏蔽后端细节呢？</p><p>第一步，利用 Spring Initializr 向导创建 Gateway 工程，确保 pom.xml 引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Nacos客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring Cloud Gateway Starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对外提供Gateway应用监控指标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，在 application.yml 增加如下配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment">#配置微服务id</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment">#nacos通信地址</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">gateway:</span> <span class="comment">#让gateway通过nacos实现自动路由转发</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#locator.enabled是自动根据URL规则实现路由转发</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#服务端口号</span></span><br><span class="line"><span class="attr">management:</span> </span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span> <span class="comment">#对外暴露actuator所有监控指标，便于监控系统收集跟踪</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的配置中<br><strong>spring.cloud.gateway.discovery.locator.enabled=true</strong></p><p>这是一个自动项，允许 Gateway 自动实现后端微服务路由转发， Gateway 工程启动后，在浏览器地址栏按下面格式访问后端服务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//网关IP:端口/微服务id/URI</span></span><br></pre></td></tr></table></figure><p>访问后 Gateway 按下图流程进行请求路由转发。</p><p><img src="/2022/05/20/2022-05-20SpringCloudGateway如何把好微服务的大门/4.png" alt="基于网关自动路由处理流程" loading="lazy"></p><center>基于网关自动路由处理流程</center><p>咱们来梳理下路由转发流程：</p><ol><li>Gateway、service-a 这些都是微服务实例，在启动时向 Nacos 注册登记；</li><li>用户端向 Gateway 发起请求，请求地址<a class="link" href="http://192.168.31.103/service-a/list%EF%BC%9B">http://192.168.31.103:80/service-a/list；<i class="fas fa-external-link-alt"></i></a></li><li>Gateway 网关实例收到请求，解析其中第二部分 service-a，即微服务 Id，第三部分 URI 为“/list”。之后向 Nacos 查询 service-a 可用实例列表；</li><li>Nacos 返回 120 与 121 两个可用微服务实例信息；</li><li>Spring Cloud Gateway 内置 Ribbon，根据默认轮询策略将请求转发至 120 实例，转发的完整 URL 将附加用户的 URI，即<a class="link" href="http://192.168.31.120/list%EF%BC%9B">http://192.168.31.120:80/list；<i class="fas fa-external-link-alt"></i></a></li><li>120 实例处理后返回 JSON 响应数据给 Gateway；</li><li>Gateway 返回给用户端，完成一次完整的请求路由转发过程。</li></ol><p>讲到这，我们已理解了 Spring Cloud Gateway 的执行过程。但是真实项目中，存在着各种特殊的路由转发规则，而非自动路由能简单解决的，在 Spring Cloud Gateway 项目中内置了强大的“谓词”系统，可以满足企业应用中的各种转发规则要求。</p><h2 id="讲解-Gateway执行原理与自定义过滤器（Filter）"><a href="#讲解-Gateway执行原理与自定义过滤器（Filter）" class="headerlink" title="讲解 Gateway执行原理与自定义过滤器（Filter）"></a>讲解 Gateway执行原理与自定义过滤器（Filter）</h2><p>在讲解前需要引入 Gateway 网关三个关键名词：路由（Route）、谓词（Predicate）、过滤器（Filter）。</p><p>路由（Route）是指一个完整的网关地址映射与处理过程。一个完整的路由包含两部分配置：谓词（Predicate）与过滤器（Filter）。前端应用发来的请求要被转发到哪个微服务上，是由谓词决定的；而转发过程中请求、响应数据被网关如何加工处理是由过滤器决定的。说起来有些晦涩，我们通过实例进行讲解就容易理解了。</p><h3 id="谓词（Predicate）"><a href="#谓词（Predicate）" class="headerlink" title="谓词（Predicate）"></a>谓词（Predicate）</h3><p>这里我们给出一个实例，将原有 Gateway 工程的 application.yml 文件修改为下面的设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="string">gateway:</span> </span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">false</span> <span class="comment">#不再需要Gateway路由转发</span></span><br><span class="line">      <span class="string">routes:</span>  <span class="comment">#路由规则配置</span></span><br><span class="line">        <span class="comment">#第一个路由配置，service-a路由规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">service_a_route</span> <span class="comment">#路由唯一标识</span></span><br><span class="line">          <span class="comment">#lb开头代表基于gateway的负载均衡策略选择实例</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service-a</span> </span><br><span class="line">          <span class="comment">#谓词配置</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">#Path路径谓词，代表用户端URI如果以/a开头便会转发到service-a实例</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/a/**</span> </span><br><span class="line">            <span class="comment">#After生效时间谓词，2020年10月15日后该路由才能在网关对外暴露</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">After=2020-10-05T00:00:00.000+08:00[Asia/Shanghai]</span></span><br><span class="line">          <span class="comment">#谓词配置</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="comment">#忽略掉第一层前缀进行转发</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span> </span><br><span class="line">            <span class="comment">#为响应头附加X-Response=Blue</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response,Blue</span> </span><br><span class="line">        <span class="comment">#第二个路由配置，service-b路由规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">service_b_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service-b</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/b/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>我来翻译下上面的配置：<br>在 2020 年 10 月 15 日后，当用户端发来/a/…开头的请求时，Spring Cloud Gateway 会自动获取 service-a 可用实例，默认采用轮询方式将URI附加至实例地址后，形成新地址，service-a处理后 Gateway 网关自动在响应头附加 X-Response=Blue。至于第二个 service_b_route，比较简单，只说明当用户访问/b开头 URL 时，转发到 service-b 可用实例。</p><p>完整的路由配置格式固定如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="string">gateway:</span> </span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">false</span>  <span class="comment">#不再需要Gateway路由转发</span></span><br><span class="line">      <span class="string">routes:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">xxx</span> <span class="comment">#路由规则id</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://微服务id</span>  <span class="comment">#路由转发至哪个微服务</span></span><br><span class="line">          <span class="string">predicates:</span> </span><br><span class="line">         <span class="string">//具体的谓词</span></span><br><span class="line">         <span class="attr">filters:</span></span><br><span class="line">         <span class="string">//具体的过滤器</span></span><br></pre></td></tr></table></figure><p>其中 predicates 是重点，说明路由生效条件，在这里我将常见的谓词使用形式列出来。</p><ul><li><p>After 代表在指定时点后路由规则生效。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">After=2020-10-04T00:00:00.000+08:00</span></span><br></pre></td></tr></table></figure></li><li><p>Before 代表在指定时点前路由规则生效。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Before=2020-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure></li><li><p>Path 代表 URI 符合映射规则时生效。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><p>如果请求具有名为 X-Request-Id 的 Header，其值与\d+正则表达式匹配（具有一个或多个数字的值），则该路由匹配。</p></li><li><p>Method 代表要求 HTTP 方法符合规定时生效。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Method=GET</span></span><br></pre></td></tr></table></figure></li></ul><p>谓词是 Gateway 网关中最灵活的部分，刚才列举的是最常用的谓词，还有很多谓词是在文中没有提到，如果你对这部分感兴趣可以翻阅<a class="link" href="https://spring.io/projects/spring-cloud-gateway%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0%E3%80%82">https://spring.io/projects/spring-cloud-gateway进行学习。<i class="fas fa-external-link-alt"></i></a></p><h3 id="过滤器（Filter）"><a href="#过滤器（Filter）" class="headerlink" title="过滤器（Filter）"></a>过滤器（Filter）</h3><p>过滤器（Filter）可以对请求或响应的数据进行额外处理，这里我们列出三个最常用的内置过滤器进行说明。</p><ul><li><p>AddRequestParameter 是对所有匹配的请求添加一个查询参数。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">AddRequestParameter=foo,bar</span> <span class="comment">#在请求参数中追加foo=bar</span></span><br></pre></td></tr></table></figure></li><li><p>AddResponseHeader 会对所有匹配的请求，在返回结果给客户端之前，在 Header 中添加响应的数据。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在Response中添加Header头，key=X-Response-Foo，Value=Bar。</span></span><br><span class="line"><span class="attr">filters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response,Blue</span></span><br></pre></td></tr></table></figure></li><li><p>Retry 为重试过滤器，当后端服务不可用时，网关会根据配置参数来发起重试请求。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line"><span class="comment">#涉及过滤器参数时，采用name-args的完整写法</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Retry</span> <span class="comment">#name是内置的过滤器名</span></span><br><span class="line">  <span class="attr">args:</span> <span class="comment">#参数部分使用args说明</span></span><br><span class="line">    <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">status:</span> <span class="number">503</span></span><br></pre></td></tr></table></figure><p>以上片段含义为，当后端服务返回 503 状态码的响应后，Retry 过滤器会重新发起请求，最多重试 3 次。</p></li></ul><p>官方资料: <a class="link" href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.6.RELEASE/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/2.2.6.RELEASE/reference/html/#gatewayfilter-factories<i class="fas fa-external-link-alt"></i></a></p><h4 id="Gateway-的执行原理与自定义过滤器"><a href="#Gateway-的执行原理与自定义过滤器" class="headerlink" title="Gateway 的执行原理与自定义过滤器"></a>Gateway 的执行原理与自定义过滤器</h4><h5 id="Spring-Cloud-Gateway-的执行原理"><a href="#Spring-Cloud-Gateway-的执行原理" class="headerlink" title="Spring Cloud Gateway 的执行原理"></a>Spring Cloud Gateway 的执行原理</h5><p>下图是 Spring Cloud Gateway 的执行流程。<br><img src="/2022/05/20/2022-05-20SpringCloudGateway如何把好微服务的大门/6.png" alt="执行流程" loading="lazy"></p><p>按执行顺序可以拆解以下几步：</p><ol><li><p>Spring Cloud Gateway 启动时基于 Netty Server 监听指定的端口（该端口可以通过 server.port 属性自定义）。当前端应用发送一个请求到网关时，进入 Gateway Handler Mapping 处理过程，网关会根据当前 Gateway 所配置的谓词（Predicate）来决定是由哪个微服务进行处理。</p></li><li><p>确定微服务后，请求向后进入 Gateway Web Handler 处理过程，该过程中 Gateway 根据过滤器（Filters）配置，将请求按前后顺序依次交给 Filter 过滤链进行前置（Pre）处理，前置处理通常是对请求进行前置检查，例如：判断是否包含某个指定请求头、检查请求的 IP 来源是否合法、请求包含的参数是否正确等。</p></li><li><p>当过滤链前置（Pre）处理完毕后，请求会被 Gateway 转发到真正的微服务实例进行处理，微服务处理后会返回响应数据，这些响应数据会按原路径返回被 Gateway 配置的过滤链进行后置处理（Post），后置处理通常是对响应进行额外处理，例如：将处理过程写入日志、为响应附加额外的响应头或者流量监控等。</p></li></ol><p>可以看到，在整个处理过程中谓词（Predicate）与过滤器（Filter）起到了重要作用，谓词决定了路径的匹配规则，让 Gateway 确定应用哪个微服务，而 Filter 则是对请求或响应作出实质的前置、后置处理。</p><p>在项目中功能场景多种多样，像日常的用户身份鉴权、日志记录、黑白名单、反爬虫等基础功能都可以通过自定义 Filter 为 Gateway 进行功能扩展，下面我们通过“计时过滤器”为例，讲解如何为 Gateway 绑定自定义全局过滤器。</p><h5 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h5><p>在 Spring Cloud Gateway 中，自定义过滤器分为两种，全局过滤器与局部过滤器。两者唯一的区别是：全局过滤器默认应用在所有路由（Route）上，而局部过滤器可以为指定的路由绑定。下面咱们通过“计时过滤器”这个案例讲解全局过滤器的配置。所谓计时过滤器是指任何从网关访问的请求，都要在日志中记录下从请求进入到响应退出的执行时间，通过这个时间运维人员便可以收集并分析哪些功能进行了慢处理，以此为依据进行进一步优化。下面是计时过滤器的代码，重要的部分我通过注释进行了说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//自动实例化并被Spring IOC容器管理</span></span><br><span class="line"><span class="comment">//全局过滤器必须实现两个接口：GlobalFilter、Ordered</span></span><br><span class="line"><span class="comment">//GlobalFilter是全局过滤器接口，实现类要实现filter()方法进行功能扩展</span></span><br><span class="line"><span class="comment">//Ordered接口用于排序，通过实现getOrder()方法返回整数代表执行当前过滤器的前后顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElapsedFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基于slf4j.Logger实现日志输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ElapsedFilter.class);</span><br><span class="line">    <span class="comment">//起始时间属性名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ELAPSED_TIME_BEGIN = <span class="string">&quot;elapsedTimeBegin&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现filter()方法记录处理时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 用于获取与当前请求、响应相关的数据，以及设置过滤器间传递的上下文数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain Gateway过滤器链对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Mono对应一个异步任务，因为Gateway是基于Netty Server异步处理的,Mono对就代表异步处理完毕的情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Pre前置处理部分</span></span><br><span class="line">        <span class="comment">//在请求到达时，往ServerWebExchange上下文环境中放入了一个属性elapsedTimeBegin，保存请求执行前的时间戳</span></span><br><span class="line">        exchange.getAttributes().put(ELAPSED_TIME_BEGIN, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//chain.filter(exchange).then()对应Post后置处理部分</span></span><br><span class="line">        <span class="comment">//当响应产生后，记录结束与elapsedTimeBegin起始时间比对，获取RESTful API的实际执行时间</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange).then(</span><br><span class="line">                Mono.fromRunnable(() -&gt; &#123; <span class="comment">//当前过滤器得到响应时，计算并打印时间</span></span><br><span class="line">                    Long startTime = exchange.getAttribute(ELAPSED_TIME_BEGIN);</span><br><span class="line">                    <span class="keyword">if</span> (startTime != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        logger.info(exchange.getRequest().getRemoteAddress() <span class="comment">//远程访问的用户地址</span></span><br><span class="line">                                + <span class="string">&quot; | &quot;</span> +  exchange.getRequest().getPath()  <span class="comment">//Gateway URI</span></span><br><span class="line">                                + <span class="string">&quot; | cost &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot;ms&quot;</span>); <span class="comment">//处理时间</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置为最高优先级，最先执行ElapsedFilter过滤器</span></span><br><span class="line">    <span class="comment">//return Ordered.LOWEST_PRECEDENCE; 代表设置为最低优先级</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后通过 Gateway 访问任意微服务便会输出日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">01</span>-<span class="number">10</span> <span class="number">12</span>:<span class="number">36</span>:<span class="number">01.765</span>  INFO <span class="number">14052</span> --- [ctor-http-nio-<span class="number">4</span>] com.group.gateway.filter.ElapsedFilter   : /<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span>:<span class="number">57873</span> | /test-service/test | cost 821ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>日志包含四部分：</p><ul><li><p>日志的基础信息包括时间、日志级别、线程、产生的类与方法等。</p></li><li><p>/0:0:0:0:0:0:0:1:57873 代表访问者的远程 IP 端口等信息。</p></li><li><p>/test-service/test 是通过 Gateway 访问的完整 URI，第一部分是服务名，第二部分是 RESTful 接口。</p></li><li><p>cost 821ms 是具体的执行时间。</p></li><li><p>以上就是全局过滤器的开发方法，至于局部过滤器的配置方法与全局过滤器极为相似，有兴趣的同学通过下面的官方文档了解更详细的内容。</p></li></ul><p>以上就是全局过滤器的开发方法，至于局部过滤器的配置方法与全局过滤器极为相似，通过下面的官方文档了解更详细的内容。<br><a class="link" href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.7.BUILD-SNAPSHOT/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/2.2.7.BUILD-SNAPSHOT/reference/html/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务门户：Spring-Cloud-Gateway-如何把好微服务的大门&quot;&gt;&lt;a href=&quot;#服务门户：Spring-Cloud-Gateway-如何把好微服务的大门&quot; class=&quot;headerlink&quot; title=&quot;服务门户：Spring Cloud Ga</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dubbo与Nacos体系如何协同作业</title>
    <link href="2022/05/14/2022-05-14Dubbo%E4%B8%8ENacos%E4%BD%93%E7%B3%BB%E5%A6%82%E4%BD%95%E5%8D%8F%E5%90%8C%E4%BD%9C%E4%B8%9A/"/>
    <id>2022/05/14/2022-05-14Dubbo%E4%B8%8ENacos%E4%BD%93%E7%B3%BB%E5%A6%82%E4%BD%95%E5%8D%8F%E5%90%8C%E4%BD%9C%E4%B8%9A/</id>
    <published>2022-05-14T12:35:28.000Z</published>
    <updated>2022-05-20T06:16:01.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC-消息：Dubbo-与-Nacos-体系如何协同作业"><a href="#RPC-消息：Dubbo-与-Nacos-体系如何协同作业" class="headerlink" title="RPC 消息：Dubbo 与 Nacos 体系如何协同作业"></a>RPC 消息：Dubbo 与 Nacos 体系如何协同作业</h1><h2 id="RESTful-与-RPC-的区别"><a href="#RESTful-与-RPC-的区别" class="headerlink" title="RESTful 与 RPC 的区别"></a>RESTful 与 RPC 的区别</h2><p>在微服务定义中提道，每个小服务运行在自己的进程中，并以轻量级的机制进行通信。这里并没有明确给出具体的通信方式，只是要求以轻量级的机制进行通信，虽然作者推荐使用 RESTful 作为首选方案，但微服务间通信本身还有另一个轻量级的选择：以 Dubbo 为代表的 RPC通信方式。</p><p>那什么是 RPC 呢？RPC 是远程过程调用（Remote Procedure Call）的缩写形式，RPC 与 RESTful 最大的不同是，RPC 采用客户端（Client) - 服务端（Server） 的架构方式实现跨进程通信，实现的通信协议也没有统一的标准，具体实现依托于研发厂商的设计。</p><p><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/1.png" alt="RPC 基于 C/S 架构实现跨进程通信" loading="lazy"></p><center>RPC 基于 C/S 架构实现跨进程通信</center><p>那 RESTful 与 RPC 孰优孰劣呢？我们通过一个表格进行说明：</p><p><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/2.png" alt="RESTful 与 RPC对比" loading="lazy"></p><p>可以发现，RESTful 通信更适合调用延时不敏感、短连接的场景。而 RPC 则拥有更好的性能，适用于长连接、低延时系统。两者本质是互补的，并不存在孰优孰劣。在微服务架构场景下，因为大多数服务都是轻量级的，同时 90%的任务通过短连接就能实现，因此马丁福勒更推荐使用 RESTful 通信。这只是因为应用场景所决定的，并不代表 RPC 比 RESTful 落后。</p><h2 id="Apache-Dubbo"><a href="#Apache-Dubbo" class="headerlink" title="Apache Dubbo"></a>Apache Dubbo</h2><p>Dubbo 是典型的 RPC 框架的代表，通过客户端/服务端结构实现跨进程应用的高效二进制通信。</p><h3 id="Apache-Dubbo-提供了六大核心能力："><a href="#Apache-Dubbo-提供了六大核心能力：" class="headerlink" title="Apache Dubbo 提供了六大核心能力："></a>Apache Dubbo 提供了六大核心能力：</h3><p><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/3.png" alt="Apache Dubbo 六大核心能力" loading="lazy"></p><center>Dubbo主要特性</center><h3 id="ApacheDubbo-的组成"><a href="#ApacheDubbo-的组成" class="headerlink" title="ApacheDubbo 的组成"></a>ApacheDubbo 的组成</h3><p><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/4.png" alt="Dubbo架构图" loading="lazy"></p><center>Dubbo架构图</center><h3 id="Dubbo-架构中，包含-5-种角色。"><a href="#Dubbo-架构中，包含-5-种角色。" class="headerlink" title="Dubbo 架构中，包含 5 种角色。"></a>Dubbo 架构中，包含 5 种角色。</h3><ul><li><p>Provider：RPC服务提供者，Provider 是消息的最终处理者。</p></li><li><p>Container：容器，用于启动、停止 Provider 服务。这里的容器并非 Tomcat、Jetty 等 Web 容器，Dubbo 也并不强制要求 Provider 必须具备 Web 能力。Dubbo 的容器是指对象容器，例如 Dubbo 内置的 SpringContainer 容器就提供了利用 Spring IOC 容器管理 Provider 对象的职能。</p></li><li><p>Consumer：消费者，调用的发起者。Consumer 需要在客户端持有 Provider 的通信接口才能完成通信过程。</p></li><li><p>Registry：注册中心，Dubbo 架构中注册中心与微服务架构中的注册中心职责类似，提供了 Dubbo Provider 的注册与发现职能，Consumer通过 Registry 可以获取Provider 可用的节点实例的 IP、端口等，并产生直接通信。需要注意的是，前面我们讲解的 Alibaba Nacos 除了可以作为微服务架构中的注册中心外，同样对自家的 Dubbo 提供了 RPC 调用注册发现的职责，这是其他 Spring Cloud 注册中心所不具备的功能。</p></li><li><p>Monitor：监控器，监控器提供了Dubbo的监控职责。在 Dubbo 产生通信时，Monitor 进行收集、统计，并通过可视化 UI 界面帮助运维人员了解系统进程间的通信状况。Dubbo Monitor 主流产品有 Dubbo Admin、Dubbo Ops 等。</p></li></ul><p>下面我们通过实例讲解 Dubbo 与 Nacos 如何协同作业实现服务间调用</p><h3 id="Dubbo与-Nacos-协同作业"><a href="#Dubbo与-Nacos-协同作业" class="headerlink" title="Dubbo与 Nacos 协同作业"></a>Dubbo与 Nacos 协同作业</h3><p>以<strong>订单与库存服务</strong>为例<br><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/6.png" alt="订单与库存服务" loading="lazy"></p><center>订单与仓储服务的业务流程</center><h4 id="开发-Provider仓储服务"><a href="#开发-Provider仓储服务" class="headerlink" title="开发 Provider仓储服务"></a>开发 Provider仓储服务</h4><h5 id="第一步，创建工程引入依赖。"><a href="#第一步，创建工程引入依赖。" class="headerlink" title="第一步，创建工程引入依赖。"></a>第一步，创建工程引入依赖。</h5><p>利用 Spring Initializr 向导创建 warehouse-service 工程，确保 pom.xml 引入以下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相比标准微服务，需要额外依赖 dubbo-spring-boot-starter 与 spring-boot-starter-actuator。其中 dubbo-spring-boot-starter 是 Dubbo 与 Spring Boot 整合最关键的组件，为 Spring Boot 提供了 Dubbo 的默认支持。而 spring-boot-starter-actuator则为微服务提供了监控指标接口，便于监控系统从应用收集各项运行指标。</p><h5 id="第二步，设置微服务、Dubbo-与-Nacos-通信选项。"><a href="#第二步，设置微服务、Dubbo-与-Nacos-通信选项。" class="headerlink" title="第二步，设置微服务、Dubbo 与 Nacos 通信选项。"></a>第二步，设置微服务、Dubbo 与 Nacos 通信选项。</h5><p>打开 application.yml 文件，配置 Nacos 地址与 Dubbo通信选项。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">warehouse-service</span> <span class="comment">#微服务id</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment">#nacos注册地址</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"><span class="attr">dubbo:</span> <span class="comment">#dubbo与nacos的通信配置</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">warehouse-dubbo</span> <span class="comment">#provider在Nacos中的应用id</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment">#Provider与Nacos通信地址，与spring.cloud.nacos地址一致</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">nacos://192.168.31.101:8848</span></span><br><span class="line">  <span class="attr">protocol:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span> <span class="comment">#通信协议名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">20880</span> <span class="comment">#配置通信端口，默认为20880</span></span><br><span class="line">  <span class="attr">scan:</span> </span><br><span class="line">    <span class="attr">base-packages:</span> <span class="string">com.lagou.warehouseservice.dubbo</span></span><br></pre></td></tr></table></figure><p>Dubbo 需要依托 Container（容器）对外暴露服务，而这个容器配置与微服务配置是分开的，需要额外占用一个网络端口20880提供服务。</p><p><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/5.png" alt="Dubbo Provider 端启动时向 Nacos 注册两次" loading="lazy"></p><center>Dubbo Provider 端启动时向 Nacos 注册两次</center><p>这里还有一个配置点需要特别注意：dubbo.scan.base-packages 代表在 Dubbo 容器启动时自动扫描 com.lagou.warehouseservice.dubbo 包下的接口与实现类，并将这些接口信息在Nacos 进行登记，因此 Dubbo 对外暴露的接口必须放在该包下。</p><h5 id="第三步，开发接口与实现类。"><a href="#第三步，开发接口与实现类。" class="headerlink" title="第三步，开发接口与实现类。"></a>第三步，开发接口与实现类。</h5><ol><li>开发 Stock 库存商品对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//库存商品对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long skuId; <span class="comment">//商品品类编号</span></span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//商品与品类名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity; <span class="comment">//库存数量</span></span><br><span class="line">    <span class="keyword">private</span> String unit; <span class="comment">//单位</span></span><br><span class="line">    <span class="keyword">private</span> String description; <span class="comment">//描述信息</span></span><br><span class="line">    <span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stock</span><span class="params">(Long skuId, String title, Integer quantity, String unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skuId = skuId;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">        <span class="keyword">this</span>.unit = unit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter 与 setter...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：Dubbo 在对象传输过程中使用了 JDK 序列化，对象必须实现 Serializable 接口。</strong></p><ol start="2"><li><p>在 com.lagou.warehouseservice.dubbo包下创建 WarehouseService 接口并声明方法。包名要与 dubbo.scan.base-packages 保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Provider接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WarehouseService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询库存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stock <span class="title">getStock</span><span class="params">(Long skuId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在 com.lagou.warehouseservice.dubbo.impl 包下创建实现类 WarehouseServiceImpl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lagou.warehouseservice.dto.Stock;</span><br><span class="line"><span class="keyword">import</span> com.lagou.warehouseservice.dubbo.WarehouseService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.DubboService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarehouseServiceImpl</span> <span class="keyword">implements</span> <span class="title">WarehouseService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stock <span class="title">getStock</span><span class="params">(Long skuId)</span></span>&#123;</span><br><span class="line">        Map result = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Stock stock = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(skuId == <span class="number">1101l</span>)&#123;</span><br><span class="line">            <span class="comment">//模拟有库存商品</span></span><br><span class="line">            stock = <span class="keyword">new</span> Stock(<span class="number">1101l</span>, <span class="string">&quot;Apple iPhone 11 128GB 紫色&quot;</span>, <span class="number">32</span>, <span class="string">&quot;台&quot;</span>);</span><br><span class="line">            stock.setDescription(<span class="string">&quot;Apple 11 紫色版对应商品描述&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skuId == <span class="number">1102l</span>)&#123;</span><br><span class="line">            <span class="comment">//模拟无库存商品</span></span><br><span class="line">            stock = <span class="keyword">new</span> Stock(<span class="number">1102l</span>, <span class="string">&quot;Apple iPhone 11 256GB 白色&quot;</span>, <span class="number">0</span>, <span class="string">&quot;台&quot;</span>);</span><br><span class="line">            stock.setDescription(<span class="string">&quot;Apple 11 白色版对应商品描述&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//演示案例，暂不考虑无对应skuId的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="第四步，启动微服务，验证-Nacos-注册信息。"><a href="#第四步，启动微服务，验证-Nacos-注册信息。" class="headerlink" title="第四步，启动微服务，验证 Nacos 注册信息。"></a>第四步，启动微服务，验证 Nacos 注册信息。</h5><p>此时在服务列表中出现了 2 条数据，warehouse-service 是仓储微服务的注册信息，providers 开头的是 Dubbo 在 Nacos 的注册 Provider 信息，这也验证了前面介绍 Dubbo 的注册过程。</p><p>而查看 Provider详情后，你会得到更多信息，其中包含 Provider 的 IP、端口、接口、方法、pid、版本的明细，方便开发、运维人员对应用进行管理。<br><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/7.png" alt="Dubbo Consumer 处理流程" loading="lazy"></p><center>Provider详情</center>到这里，仓储服务与 Dubbo Provider 的开发已完成。下面咱们开发Consumer消费者。<h4 id="开发-Consumer-订单服务"><a href="#开发-Consumer-订单服务" class="headerlink" title="开发 Consumer 订单服务"></a>开发 Consumer 订单服务</h4><h5 id="第一步，创建工程引入依赖。-1"><a href="#第一步，创建工程引入依赖。-1" class="headerlink" title="第一步，创建工程引入依赖。"></a>第一步，创建工程引入依赖。</h5><p>利用 Spring Initializr 向导创建 order-service 工程，确保 pom.xml 引入以下依赖，依赖部分与 warehouse-service 保持一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="第二步，设置微服务、Dubbo-与-Nacos通信选项。"><a href="#第二步，设置微服务、Dubbo-与-Nacos通信选项。" class="headerlink" title="第二步，设置微服务、Dubbo 与 Nacos通信选项。"></a>第二步，设置微服务、Dubbo 与 Nacos通信选项。</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-service-dubbo</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">nacos://192.168.31.101:8848</span></span><br></pre></td></tr></table></figure><h5 id="第三步，将-Provider-端接口-WarehouseService-以及依赖的-Stock类复制到-order-service-工程"><a href="#第三步，将-Provider-端接口-WarehouseService-以及依赖的-Stock类复制到-order-service-工程" class="headerlink" title="第三步，将 Provider 端接口 WarehouseService 以及依赖的 Stock类复制到 order-service 工程"></a>第三步，将 Provider 端接口 WarehouseService 以及依赖的 Stock类复制到 order-service 工程</h5><p>注意要求包名、类名及代码保持完全一致。当然我这种做法比较原始，在项目环境通常是将接口与依赖的类发布到 Maven 仓库，由 Consumer 直接依赖即可。<br><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/8.png" alt="依赖" loading="lazy"></p><center>必须保证 Provider 与 Consumer 接口一致</center><h5 id="第四步，Consumer-调用接口实现业务逻辑"><a href="#第四步，Consumer-调用接口实现业务逻辑" class="headerlink" title="第四步，Consumer 调用接口实现业务逻辑"></a>第四步，Consumer 调用接口实现业务逻辑</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DubboReference</span></span><br><span class="line">    <span class="keyword">private</span> WarehouseService warehouseService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单业务逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId 商品类别编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> salesQuantity 销售数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/create_order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">createOrder</span><span class="params">(Long skuId , Long salesQuantity)</span></span>&#123;</span><br><span class="line">        Map result = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        <span class="comment">//查询商品库存，像调用本地方法一样完成业务逻辑。</span></span><br><span class="line">        Stock stock = warehouseService.getStock(skuId);</span><br><span class="line">        System.out.println(stock);</span><br><span class="line">        <span class="keyword">if</span>(salesQuantity &lt;= stock.getQuantity())&#123;</span><br><span class="line">            <span class="comment">//创建订单相关代码，此处省略</span></span><br><span class="line">            <span class="comment">//CODE=SUCCESS代表订单创建成功</span></span><br><span class="line">            result.put(<span class="string">&quot;code&quot;</span> , <span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">            result.put(<span class="string">&quot;skuId&quot;</span>, skuId);</span><br><span class="line">            result.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;订单创建成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//code=NOT_ENOUGN_STOCK代表库存不足</span></span><br><span class="line">            result.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;NOT_ENOUGH_STOCK&quot;</span>);</span><br><span class="line">            result.put(<span class="string">&quot;skuId&quot;</span>, skuId);</span><br><span class="line">            result.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;商品库存数量不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务逻辑非常简单，前文讲过不再赘述，关键点是第三行 @DubboReference 注解。该注解用在 Consumer 端，说明 WarehouseService 是 Dubbo Consumer 接口，Spring 会自动生成 WarehouseService 接口的代理实现类，并隐藏远程通信细节，处理流程如下图所示：</p><p><img src="/2022/05/14/2022-05-14Dubbo与Nacos体系如何协同作业/9.png" alt="Dubbo Consumer 处理流程" loading="lazy"></p><center>Dubbo Consumer 处理流程</center><h5 id="第五步，启动微服务，验证-Nacos-注册信息。"><a href="#第五步，启动微服务，验证-Nacos-注册信息。" class="headerlink" title="第五步，启动微服务，验证 Nacos 注册信息。"></a>第五步，启动微服务，验证 Nacos 注册信息。</h5><p>打开浏览器访问下面网址验证结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//192.168.31.106:9000/create_order?skuId=1101&amp;salesQuantity=10</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">code</span>: <span class="string">&quot;SUCCESS&quot;</span>,</span><br><span class="line"><span class="attr">skuId</span>: <span class="number">1101</span>,</span><br><span class="line"><span class="attr">message</span>: <span class="string">&quot;订单创建成功&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC-消息：Dubbo-与-Nacos-体系如何协同作业&quot;&gt;&lt;a href=&quot;#RPC-消息：Dubbo-与-Nacos-体系如何协同作业&quot; class=&quot;headerlink&quot; title=&quot;RPC 消息：Dubbo 与 Nacos 体系如何协同作业&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ribbon负载均衡策略</title>
    <link href="2022/05/08/2022-05-08Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <id>2022/05/08/2022-05-08Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</id>
    <published>2022-05-08T07:51:33.000Z</published>
    <updated>2022-05-14T12:34:15.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ribbon负载均衡策略"><a href="#Ribbon负载均衡策略" class="headerlink" title="Ribbon负载均衡策略"></a>Ribbon负载均衡策略</h1><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>指通过软件或者硬件措施。它将来自客户端的请求按照某种策略平均的分配到集群的每一个节点上，保证这些节点的 CPU、内存等设备负载情况大致在一条水平线，避免由于局部节点负载过高产生宕机，再将这些处理压力传递到其他节点上产生系统性崩溃。</p><p>负载均衡按实现方式分类可区分为：<strong>服务端负载均衡</strong>与<strong>客户端负载均衡</strong>。</p><h3 id="服务端负载均衡"><a href="#服务端负载均衡" class="headerlink" title="服务端负载均衡"></a>服务端负载均衡</h3><p>在架构中会提供专用的负载均衡器，由负载均衡器持有后端节点的信息，服务消费者发来的请求经由专用的负载均衡器分发给服务提供者，进而实现负载均衡的作用。目前常用的负载均衡器软硬件有：F5、Nginx、HaProxy 等。<br><img src="/2022/05/08/2022-05-08Ribbon负载均衡策略/1.png" alt="服务端负载均衡" loading="lazy"></p><h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p>在架构中不再部署额外的负载均衡器，在每个服务消费者内部持有客户端负载均衡器，由内置的负载均衡策略决定向哪个服务提供者发起请求。说到这，我们的主角登场了，Netfilx Ribbon 是 Netflix 公司开源的一个负载均衡组件，是属于客户端负载均衡器。目前Ribbon 已被 Spring Cloud 官方技术生态整合，运行时以 SDK 形式内嵌到每一个微服务实例中，为微服务间通信提供负载均衡与高可用支持。为了更容易理解，我们通过应用场景说明 Ribbon 的执行流程。假设订单服务在查询订单时需要附带对应商品详情，这就意味着订单服务依赖于商品服务，两者必然产生服务间通信，此时 Ribbon 的执行过程如下图所示：<br><img src="/2022/05/08/2022-05-08Ribbon负载均衡策略/2.png" alt="客户端负载均衡" loading="lazy"></p><h2 id="netflix-Ribbon"><a href="#netflix-Ribbon" class="headerlink" title="netflix.Ribbon"></a>netflix.Ribbon</h2><p>负载均衡策略的本质都是com.netflix.loadbalancer包下的类<br><img src="/2022/05/08/2022-05-08Ribbon负载均衡策略/3.png" alt="netflix.Ribbon" loading="lazy"></p><h3 id="RoundRobinRule"><a href="#RoundRobinRule" class="headerlink" title="RoundRobinRule"></a>RoundRobinRule</h3><center>轮询策略，Ribbon默认策略</center>默认超过10次获取到的server都不可用，会返回一个空的server<h3 id="RandomRule"><a href="#RandomRule" class="headerlink" title="RandomRule"></a>RandomRule</h3><center>随机策略</center>如果随机到的server为null或者不可用的话，会不停的循环选取没有失效时间的概念，只要serverList没都挂<h3 id="RetryRule"><a href="#RetryRule" class="headerlink" title="RetryRule"></a>RetryRule</h3><center>重试策略，一定时限内循环重试</center>每次选取后，对选举的server进行判断是否为null，是否alive，并且在500ms内不停的选取判断<h3 id="BestAvailableRule"><a href="#BestAvailableRule" class="headerlink" title="BestAvailableRule"></a>BestAvailableRule</h3><center>最小连接数策略</center>遍历serverList，选取出可用的且连接数最小的一个server会调用RoundRobinRule重新选取<h3 id="AvailabilityFilteringRule"><a href="#AvailabilityFilteringRule" class="headerlink" title="AvailabilityFilteringRule"></a>AvailabilityFilteringRule</h3><center>可用过滤策略</center>扩展了轮询策略，会先通过默认的轮询选取一个server再去判断该server是否超时可用、当前连接数是否超限，都成功再返回<h3 id="ZoneAvoidanceRule"><a href="#ZoneAvoidanceRule" class="headerlink" title="ZoneAvoidanceRule"></a>ZoneAvoidanceRule</h3><center>区域权衡策略</center>扩展了轮询策略，除了过滤超时和连接数过多的server还会过滤掉不符合要求的zone区域里面的所有节点始终保证在一个区域/机房内的服务实例进行轮询<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>OpenFeign相比RestTemplate技术，大幅简化了服务间高通信可用处理过程</p><h3 id="Feign-与-OpenFeign"><a href="#Feign-与-OpenFeign" class="headerlink" title="Feign 与 OpenFeign"></a>Feign 与 OpenFeign</h3><p>Spring Cloud OpenFeign 并不是独立的技术。它底层基于 Netflix Feign，Netflix Feign 是 Netflix 设计的开源的声明式 WebService 客户端，用于简化服务间通信。Netflix Feign 采用 <strong>“接口+注解”</strong> 的方式开发，通过模仿 RPC 的客户端与服务器模式（CS），采用接口方式开发来屏蔽网络通信的细节。OpenFeign 则是在 Netflix Feign 的基础上进行封装，结合原有 Spring MVC 的注解，对 Spring Cloud 微服务通信提供了良好的支持。使用 OpenFeign 开发的方式与开发 Spring MVC Controller 颇为相似。</p><p>创建OpenFeign的通信接口与响应对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lagou.orderservice.feignclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lagou.orderservice.dto.Stock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;warehouse-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WarehouseServiceFeignClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/stock&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stock <span class="title">getStock</span><span class="params">(<span class="meta">@RequestParam(&quot;skuId&quot;)</span> Long skuId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个 feignclient 包用于保存通信接口。OpenFeign 通过“接口+注解”形式描述数据传输逻辑，并不需要程序员编写具体实现代码便能实现服务间高可用通信，下面我们来学习这段代码：</p><ul><li><p>@FeignClient 注解说明当前接口为 OpenFeign 通信客户端，参数值 warehouse-service 为服务提供者 ID，这一项必须与 Nacos 注册 ID 保持一致。在 OpenFeign 发送请求前会自动在 Nacos 查询 warehouse-service 所有可用实例信息，再通过内置的 Ribbon 负载均衡选择一个实例发起 RESTful 请求，进而保证通信高可用。</p></li><li><p>声明的方法结构，接口中定义的方法通常与服务提供者的方法定义保持一致。这里有个非常重要的细节：用于接收数据的 Stock 对象并不强制要求与提供者端 Stock 对象完全相同，消费者端的 Stock 类可以根据业务需要删减属性，但属性必须要与提供者响应的 JSON 属性保持一致。距离说明，我们在代码发现消费者端 Stock 的包名与代码与提供者都不尽相同，而且因为消费者不需要 description 属性便将其删除，其余属性只要保证与服务提供者响应 JSON 保持一致，在 OpenFeign 获取响应后便根据 JSON 属性名自动反序列化到 Stock 对象中。</p></li><li><p>@GetMapping/@PostMapping，以前我们在编写 Spring MVC 控制器时经常使用 @GetMapping 或者@ PostMapping 声明映射方法的请求类型。虽然 OpenFeign 也使用了这些注解，但含义完全不同。在消费者端这些注解的含义是：OpenFeign 向服务提供者 warehouse-service 的 stock 接口发起 Get 请求。简单总结下，如果在服务提供者书写 @GetMapping 是说明 Controller 接收数据的请求类型必须是 Get，而写在消费者端接口中则说明 OpenFeign 采用 Get 请求发送数据，大多数情况下消费者发送的请求类型、URI 与提供者定义要保持一致。</p></li><li><p>@RequestParam，该注解说明方法参数与请求参数之间的映射关系。举例说明，当调用接口的 getStock() 方法时 skuId 参数值为 1101，那实际通信时 OpenFeign 发送的 Get 请求格式就是：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//warehouse-service可用实例 ip:端口/stock?skuId=1101</span></span><br></pre></td></tr></table></figure><p>介绍每一个细节后，我用自然语言完整描述<strong>处理逻辑</strong>：</p><ol><li><p>在第一次访问 WarehouseServiceFeignClient 接口时，Spring 自动生成接口的实现类并实例化对象。</p></li><li><p>当调用 getStock() 方法时，Ribbon 获取 warehouse-service 可用实例信息，根据负载均衡策略选择合适实例。</p></li><li><p>OpenFeign 根据方法上注解描述的映射关系生成完整的 URL 并发送 HTTP 请求，如果请求方法是 @PostMapping，则参数会附加在请求体中进行发送。</p></li><li><p>warehouse-service 处理完毕返回 JSON 数据，消费者端 OpenFeign 接收 JSON 的同时反序列化到 Stock 对象，并将该对象返回。</p></li></ol><h2 id="生产环境-OpenFeign-的配置事项"><a href="#生产环境-OpenFeign-的配置事项" class="headerlink" title="生产环境 OpenFeign 的配置事项"></a>生产环境 OpenFeign 的配置事项</h2><p><strong>Spring Cloud OpenFeign的官方文档</strong><br><a class="link" href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.6.RELEASE/reference/html/">https://docs.spring.io/spring-cloud-openfeign/docs/2.2.6.RELEASE/reference/html/<i class="fas fa-external-link-alt"></i></a></p><h3 id="更改默认的负载均衡策略"><a href="#更改默认的负载均衡策略" class="headerlink" title="更改默认的负载均衡策略"></a>更改默认的负载均衡策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">warehouse-service: #服务提供者的微服务ID</span><br><span class="line">  ribbon:</span><br><span class="line">    #设置对应的负载均衡类</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure><h3 id="开启默认数据压缩功能"><a href="#开启默认数据压缩功能" class="headerlink" title="开启默认数据压缩功能"></a>开启默认数据压缩功能</h3><p>在 OpenFeign 中，默认并没有开启数据压缩功能。但如果你在服务间单次传递数据超过 1K 字节，强烈推荐开启数据压缩功能。默认 OpenFeign 使用 Gzip 方式压缩数据，对于大文本通常压缩后尺寸只相当于原始数据的 10%~30%，这会极大提高带宽利用率。但有一种情况除外，如果应用属于计算密集型，CPU 负载长期超过 70%，因数据压缩、解压缩都需要 CPU 运算，开启数据压缩功能反而会给 CPU 增加额外负担，导致系统性能降低，这是不可取的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  compression:</span><br><span class="line">    request:</span><br><span class="line">      # 开启请求数据的压缩功能</span><br><span class="line">      enabled: <span class="keyword">true</span></span><br><span class="line">      # 压缩支持的MIME类型</span><br><span class="line">      mime-types: text/xml,application/xml, application/json</span><br><span class="line">      # 数据压缩下限 <span class="number">1024</span>表示传输数据大于<span class="number">1024</span> 才会进行数据压缩(最小压缩值标准)</span><br><span class="line">      min-request-size: <span class="number">1024</span></span><br><span class="line">    # 开启响应数据的压缩功能</span><br><span class="line">    response:</span><br><span class="line">      enabled: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="替换默认通信组件"><a href="#替换默认通信组件" class="headerlink" title="替换默认通信组件"></a>替换默认通信组件</h3><ol><li>引入 feign-okhttp 依赖包。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">11.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在应用入口，利用 Java Config 形式初始化 OkHttpClient 对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Spring IOC容器初始化时构建okHttpClient对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> okhttp3.<span class="function">OkHttpClient <span class="title">okHttpClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> okhttp3.OkHttpClient.Builder()</span><br><span class="line">                <span class="comment">//读取超时时间</span></span><br><span class="line">                .readTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//连接超时时间</span></span><br><span class="line">                .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//写超时时间</span></span><br><span class="line">                .writeTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//设置连接池</span></span><br><span class="line">                .connectionPool(<span class="keyword">new</span> ConnectionPool())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 application.yml 中启用 OkHttp。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  okhttp:</span><br><span class="line">    enabled: <span class="keyword">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ribbon负载均衡策略&quot;&gt;&lt;a href=&quot;#Ribbon负载均衡策略&quot; class=&quot;headerlink&quot; title=&quot;Ribbon负载均衡策略&quot;&gt;&lt;/a&gt;Ribbon负载均衡策略&lt;/h1&gt;&lt;h2 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务生态与springCloudAlibaba</title>
    <link href="2022/05/05/2022-05-05%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81%E4%B8%8EspringCloudAlibaba/"/>
    <id>2022/05/05/2022-05-05%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81%E4%B8%8EspringCloudAlibaba/</id>
    <published>2022-05-05T13:59:59.000Z</published>
    <updated>2022-05-07T01:18:23.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顶层设计：微服务生态与SpringCloudAlibaba"><a href="#顶层设计：微服务生态与SpringCloudAlibaba" class="headerlink" title="顶层设计：微服务生态与SpringCloudAlibaba"></a>顶层设计：微服务生态与SpringCloudAlibaba</h1><h2 id="通用的微服务架构应包含哪些组件"><a href="#通用的微服务架构应包含哪些组件" class="headerlink" title="通用的微服务架构应包含哪些组件"></a>通用的微服务架构应包含哪些组件</h2><p>相对于单体式架构的简单粗暴，微服务架构将应用打散，形成多个微服务进行独立开发、测试、部署与运维。虽然从管理与逻辑上更符合业务需要，但微服务架构也带来了诸多急需解决的核心问题：</p><ol><li><p>如何发现新服务节点以及检查服务节点的状态？</p></li><li><p>如何发现服务及负载均衡如何实现？</p></li><li><p>服务间如何进行消息通信？</p></li><li><p>如何对使用者暴露服务 API？</p></li><li><p>如何集中管理众多服务节点的配置文件？</p></li><li><p>如何收集服务节点的日志并统一管理？</p></li><li><p>如何实现服务间调用链路追踪？</p></li><li><p>如何对系统进行链路保护，避免微服务雪崩？</p></li></ol><p>业内已经有了标准答案，下图清晰的说明微服务架构需要的标准组件。<br><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/1.png" alt="微服务架构标准组件" loading="lazy"></p><center>微服务架构标准组件</center><h3 id="下面我来介绍每种组件的职责。"><a href="#下面我来介绍每种组件的职责。" class="headerlink" title="下面我来介绍每种组件的职责。"></a>下面我来介绍每种组件的职责。</h3><ul><li><h5 id="注册中心（Service-Registry）"><a href="#注册中心（Service-Registry）" class="headerlink" title="注册中心（Service Registry）"></a>注册中心（Service Registry）</h5><p>注册中心是微服务架构最核心的组件。它起到新服务节点的注册与状态维护的作用，通过注册中心解决了上述问题 1。微服务节点在启动时会将自身的服务名称、IP、端口等信息在注册中心中进行登记，注册中心会定时检查该节点的运行状态。注册中心通常会采用心跳机制最大程度保证其持有的服务节点列表都是可用的。<br><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/2.png" alt="服务注册流程" loading="lazy"></p><center>服务注册流程</center></li><li><h5 id="负载均衡（Load-Balance）"><a href="#负载均衡（Load-Balance）" class="headerlink" title="负载均衡（Load Balance）"></a>负载均衡（Load Balance）</h5><p>负载均衡器解决了问题 2。通常在微服务彼此调用时并不是直接通过IP、端口直接访问，而是首先通过服务名在注册中心查询该服务拥有哪些可用节点，然后注册中心将可用节点列表返回给服务调用者，这个过程称为“服务发现”。因服务高可用的要求，服务调用者会接收到多个可用节点，必须要从中进行选择，因此在服务调用者一端必须内置负载均衡器，通过负载均衡策略选择适合的节点发起实质的通信请求。<br><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/3.png" alt="服务发现与负载均衡" loading="lazy"></p><center>服务发现与负载均衡</center></li><li><h4 id="服务通信（Communication）"><a href="#服务通信（Communication）" class="headerlink" title="服务通信（Communication）"></a>服务通信（Communication）</h4><p>服务通信组件解决了问题 3。在微服务定义中阐述服务间通信采用轻量级协议，通常是 HTTP RESTful 风格。但因 RESTful 风格过于灵活，必须加以约束，通常在应用时对其进行上层封装，例如在 Spring Cloud 中就提供了 Feign 和 RestTemplate 两种技术屏蔽底层实现 RESTful 通信细节，所有开发者是基于封装后统一的SDK进行开发，这有利于团队间协作。</p></li><li><h4 id="API-服务网关（API-Gateway）"><a href="#API-服务网关（API-Gateway）" class="headerlink" title="API 服务网关（API Gateway）"></a>API 服务网关（API Gateway）</h4><p>服务网关解决问题 4。对于最终用户来说，微服务的通信与各种实现细节应该是透明的，用户只需关注他要使用的 API 接口即可。因此微服务架构引入服务网关控制用户的访问权限。服务网关是外部环境访问内部微服务的唯一途径，在这个基础上还可以扩展出其他功能，例如：用户认证与授权、容错限流、动态路由、A/B测试、灰度发布等。<br><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/4.png" alt="API 服务网关" loading="lazy"></p><center>API 服务网关</center></li><li><h4 id="配置中心（Config-Management）"><a href="#配置中心（Config-Management）" class="headerlink" title="配置中心（Config Management）"></a>配置中心（Config Management）</h4><p>配置中心解决问题 5。微服务架构下，微服务节点都包含自己的各种配置文件，如JDBC地址、自定义配置、环境配置等。要知道互联网公司微服务节点可能是成千上万个，如果这些配置信息分散存储在节点上，如发生配置变更就必须逐个调整，这必将给运维人员带来巨大的工作量。配置中心便因此而生，通过部署配置中心服务器，将原本分散的配置文件从应用中剥离，集中转存到配置中心。一般配置中心会提供 UI 界面，可以方便快捷的实现大规模集群的配置调整。<br><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/5.png" alt="庞杂而重复的配置文件" loading="lazy"></p><center>庞杂而重复的配置文件</center></li></ul><p><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/6.png" alt="引入配置中心集中管理配置" loading="lazy"></p><center>引入配置中心集中管理配置</center><ul><li><h4 id="集中式日志管理（Centralized-Logging）"><a href="#集中式日志管理（Centralized-Logging）" class="headerlink" title="集中式日志管理（Centralized Logging）"></a>集中式日志管理（Centralized Logging）</h4><p>集中式日志解决问题 6。因为微服务架构默认将应用日志分散保存在每一个微服务节点上，当系统进行用户行为分析、数据统计时必须收集所有节点日志数据。那如何有效收集所有节点的运行日志，并对其进行分析汇总呢？业内常见的方案有 ELK、EFK，通过搭建独立的日志收集系统，定时抓取增量日志形成有效的统计报表，为决策提供数据支撑。<br><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/7.png" alt="ELK 日志收集系统" loading="lazy"></p><center>ELK 日志收集系统</center></li><li><h4 id="分布式链路追踪（Distributed-Tracing）"><a href="#分布式链路追踪（Distributed-Tracing）" class="headerlink" title="分布式链路追踪（Distributed Tracing）"></a>分布式链路追踪（Distributed Tracing）</h4><p>分布式追踪解决问题 7。一个复杂的业务流程可能需要连续调用多个微服务，我们需要记录一个完整业务逻辑涉及的每一个微服务的运行状态，再通过可视化链路图展现，帮助软件工程师在系统出错时分析解决问题。<br><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/8.png" alt="微服务链路追踪" loading="lazy"></p><center>微服务链路追踪</center></li></ul><p><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/9.png" alt="Zipkin 链路图" loading="lazy"></p><center>Zipkin 链路图</center><ul><li><h4 id="服务保护（Service-Protection）"><a href="#服务保护（Service-Protection）" class="headerlink" title="服务保护（Service Protection）"></a>服务保护（Service Protection）</h4>服务保护解决问题 8。在服务间通信过程中，如果某个微服务出现响应高延迟可能会导致线程池满载，严重时会引起系统崩溃。这里就需要引入服务保护组件实现高延迟服务的快速降级，避免系统崩溃。</li></ul><h2 id="Spring-Cloud-是如何支撑微服务架构的"><a href="#Spring-Cloud-是如何支撑微服务架构的" class="headerlink" title="Spring Cloud 是如何支撑微服务架构的"></a>Spring Cloud 是如何支撑微服务架构的</h2><p>下面这张图很好地诠释了 Spring、Spring Boot、Spring Cloud 它们之间的关系。</p><p>Spring 是整个微服务开发生态的基石，在此基础上 Spring 经过封装和简化，形成了Spring Boot 敏捷开发框架，而 Spring Cloud 开发微服务则必须掌握 Spring Boot。</p><p>Spring Cloud 提供了完整的微服务架构的技术生态，像刚才我们提到的微服务架构标准组件，在 Spring Cloud 中都有着对应的实现。</p><p><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/10.png" alt="Spring Cloud 内置组件" loading="lazy"></p><center>Spring Cloud 内置组件</center><h3 id="功能更强大的国产微服务生态Spring-Cloud-Alibaba"><a href="#功能更强大的国产微服务生态Spring-Cloud-Alibaba" class="headerlink" title="功能更强大的国产微服务生态Spring Cloud Alibaba"></a>功能更强大的国产微服务生态Spring Cloud Alibaba</h3><p>Spring Cloud Alibaba是直接隶属于 Spring Cloud 的子项目。官网是：<a class="link" href="https://spring.io/projects/spring-cloud-alibaba#overview">https://spring.io/projects/spring-cloud-alibaba#overview<i class="fas fa-external-link-alt"></i></a></p><p>Spring Cloud Alibaba是国产的微服务开发一站式解决方案，与原有 Spring Cloud 兼容的同时对微服务生态进行扩展，通过添加少量的配置注解，便可实现更符合国情的微服务架构。</p><p>下面是 Spring Cloud 与 Spring Cloud Alibaba 的对比。</p><p><img src="/2022/05/05/2022-05-05微服务生态与springCloudAlibaba/11.png" alt="Spring Cloud 与 Spring Cloud Alibaba 的对比" loading="lazy"></p><center>Spring Cloud 与 Spring Cloud Alibaba 的对比</center>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;顶层设计：微服务生态与SpringCloudAlibaba&quot;&gt;&lt;a href=&quot;#顶层设计：微服务生态与SpringCloudAlibaba&quot; class=&quot;headerlink&quot; title=&quot;顶层设计：微服务生态与SpringCloudAlibaba&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务架构设计</title>
    <link href="2022/05/04/2022-05-04%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>2022/05/04/2022-05-04%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-05-04T11:24:59.000Z</published>
    <updated>2022-05-08T07:00:18.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务架构设计"><a href="#微服务架构设计" class="headerlink" title="微服务架构设计"></a>微服务架构设计</h1><h2 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h2><p>所谓微服务架构风格是一种将单机应用程序开发为一组小型服务的方法，每个小服务运行在自己的进程中，并以轻量级的机制来进行通信。这些服务围绕着业务能力所建立，并且由完全自动化的部署机构独立部署，这些服务的集中管理只有最低限度，可以用不同的编程语言编写并使用不同的数据库存储技术。</p><h2 id="垂直划分的分布式应用具有哪些问题？"><a href="#垂直划分的分布式应用具有哪些问题？" class="headerlink" title="垂直划分的分布式应用具有哪些问题？"></a>垂直划分的分布式应用具有哪些问题？</h2><p>在早期构建分布式应用时，多系统间协作其实是一件比较困难的事情。</p><ol><li><h3 id="首先，系统间通信困难。"><a href="#首先，系统间通信困难。" class="headerlink" title="首先，系统间通信困难。"></a>首先，系统间通信困难。</h3><p>在 WebService 跨进程调用时，需要双方持有相同的传输对象才可以完成数据的交互。但如果服务的提供者，他将接口以及传输对象进行升级后，而客户端没有及时更新的话，此时便会因为对象的状态不一致导致传输失败的情况。要知道在互联网机构，接口的升级与扩展可能是一件频繁发生的事情，如果这类问题一再出现，必然会影响系统的稳定性和团队的协作</p></li><li><h3 id="系统的内部复杂度对外暴露"><a href="#系统的内部复杂度对外暴露" class="headerlink" title="系统的内部复杂度对外暴露"></a>系统的内部复杂度对外暴露</h3><p>系统的负载增大时，此时为集群加入了额外的两个节点，无法通知其他系统额外扩展这两个新加入的节点，增加了两个系统之间的耦合</p></li><li><h3 id="系统间的调用关系复杂"><a href="#系统间的调用关系复杂" class="headerlink" title="系统间的调用关系复杂"></a>系统间的调用关系复杂</h3></li><li><h3 id="过度的重复建设"><a href="#过度的重复建设" class="headerlink" title="过度的重复建设"></a>过度的重复建设</h3><p>在公司进行项目开发时，因为是每一个团队负责独立的系统，而这些系统往往需要一些通用的底层设施。例如：用户认证与权限控制、黑名单白名单、流量控制与系统异常的处理以及系统参数的配置管理等模块。而这些模块在每一个子系统中都要重复的进行开发，这显然是一件费时费力的事情，不利于数据的集中管理。</p></li><li><h3 id="“大一统”的架构设计"><a href="#“大一统”的架构设计" class="headerlink" title="“大一统”的架构设计"></a>“大一统”的架构设计</h3><p>所谓大一统架构设计，是指很多公司希望采用一套统一的架构来适应公司各个不同职能的子系统。比如，之前所有的系统是将数据统一存放在性能强大的 Oracle 数据库集群中。但这里有一个弊端，某个系统，需要对用户开放大量的全文检索。如果你对数据检索技术有了解，会明白Oracle这种关系型数据库并不擅长全文检索功能，实际应交给Elasticsearch全文检索引擎进行处理。<br>但其他系统并不需要，但因为大一统的架构设计约束，其他系统也必须要支持 Elasticsearch，这显然是不合理的。</p></li></ol><h2 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h2><ul><li><p>构建基于业务、可重用、职责明确的小型服务；</p></li><li><p>统一的通信标准，轻量级的通信协议，通常这里的通信协议是指的 RESTful；</p></li><li><p>可独立运行，独立存储由独立团队进行维护。</p></li></ul><p><strong>微服务改造以后，我们的架构会变成这个样子</strong><br><img src="/2022/05/04/2022-05-04微服务架构设计/1.png" alt="微服务架构" loading="lazy"><br>我们将原有的各个子系统中的核心的服务进行了抽象形成服务层，而在服务层中又可以按照是否与业务相关，分为业务服务层和基础服务层。</p><p>其中业务服务层是原有各个子系统中抽象出来的可以被充分重用的服务模块，原有借款人门户中普惠金融的业务逻辑可以剥离为普惠金融服务，同时由专门的团队对其进行维护。作为服务，它有着独立的 Oracle 数据库进行存储，相类似的贷后催收也都有相应的服务来进行支撑，拥有独立的团队以及独立的数据存储。</p><p>而在最下方的基础服务层，则是抽象出一个与业务无关的底层的基础设施。例如数据同步服务、配置中心服务、全文检索服务它都是面向所有服务对外暴露的。</p><p>以上就是改造后的微服务架构。那么，分布式系统传统的问题是如何通过微服务架构解决的，咱们分别来看。</p><h3 id="微服务架构提供了轻松而统一的进程间通信标准"><a href="#微服务架构提供了轻松而统一的进程间通信标准" class="headerlink" title="微服务架构提供了轻松而统一的进程间通信标准"></a>微服务架构提供了轻松而统一的进程间通信标准</h3><p>之前采用 WebService，要求客户端和服务端必须持有相同的通信对象。在改为 RESTful 通信后，RESTful 是基于 HTTP 协议的轻量级通信方式。它并不强制要求客户端一定持有通信对象，可以使用 Java 中的 HttpClient或者 OkHttp 组件，发起标准的 HTTP 请求就可以通信，返回的数据也是标准的 JSON 结构。对于这样的通信形式，在我们实际使用时，如果单纯由服务端进行了响应数据的扩展，在后续通信时是并不强制要求调用端必须对代码进行升级，服务端与调用端是彼此兼容的。</p><h3 id="屏蔽分布式应用的应用复杂度"><a href="#屏蔽分布式应用的应用复杂度" class="headerlink" title="屏蔽分布式应用的应用复杂度"></a>屏蔽分布式应用的应用复杂度</h3><p>假设贷后服务额外增加了两个节点，对于微服务架构来说，它有一个关键组件名为注册中心，下面是具体的执行顺序：</p><p>信审服务和贷后服务，它在启动时会将服务可用的节点的 IP 以及相应状态在注册中心中进行登记。</p><p>当信审服务向贷后服务发起调用通知之前，首先信审服务从注册中心中获取贷后服务可用的 IP 列表。</p><p>信审服务根据某种负载均衡规则，向具体的节点发起 HTTP 请求来完成业务的处理。</p><p>因为所有的 IP 地址以及节点的状态都是由注册中心来维护的，所以信审服务作为使用者，是不需要了解贷后服务有具体哪些节点的。这就有效地降低了分布式应用之间的耦合，提高了程序的可维护性。<br><img src="/2022/05/04/2022-05-04微服务架构设计/2.png" alt="微服务注册中心" loading="lazy"></p><h3 id="内建链路跟踪体系"><a href="#内建链路跟踪体系" class="headerlink" title="内建链路跟踪体系"></a>内建链路跟踪体系</h3><p>在传统的分布式应用中，要梳理服务间的调用关系，实际是一件很烦琐的事情。到了微服务体系下，这个问题就很好解决。因为微服务标准中提供了链路跟踪的技术实现。以当前为例，有三个服务 A、B、C，如图所示，ABC 三个服务之间的调用顺序以及调用时长一目了然。通过可视化的形式，可以直观了解服务间的通信过程以及通信的状态，帮助我们对程序进行进一步的管理。</p><p><img src="/2022/05/04/2022-05-04微服务架构设计/3.png" alt="微服务链路跟踪" loading="lazy"></p><h3 id="减少重复建设"><a href="#减少重复建设" class="headerlink" title="减少重复建设"></a>减少重复建设</h3><p>基础数据管理更加集中。在微服务体系中，这里有一个用户认证中心的服务，其本意在前端应用实际发起请求前，对用户的身份和权限来进行判断。不同系统用户认证的过程都是类似的，我们把它抽象出一个通用的用户认证中心，这样做不但可以减少每一个子系统的重复建设，还可以将用户这个信息来进行集中的统一存储。</p><h3 id="弹性的架构设计"><a href="#弹性的架构设计" class="headerlink" title="弹性的架构设计"></a>弹性的架构设计</h3><p>假如借款人门户需要全文检索的支持，那么与之对应的普惠金融服务中，便可以为其专门增加 Elasticsearch 来进行支持。对于某一个服务加入新的特性，并不影响其他服务的运行。</p><p><img src="/2022/05/04/2022-05-04微服务架构设计/4.png" alt="微服务链路跟踪" loading="lazy"></p><p>之后随着业务的不断演化，其他服务假如也需要 Elasticsearch 全文检索的话，这时我们便可以进行进一步抽象。剥离出”全文检索服务”基础服务，来为其他服务提供支撑。因为在微服务架构中，我们采用了统一的标准来进行开发，所以它的升级改造工作难度比较小。</p><p><img src="/2022/05/04/2022-05-04微服务架构设计/5.png" alt="微服务链路跟踪" loading="lazy"></p><center>下沉为基础服务</center><p>可以看到引入微服务后因为有了统一的分布式应用标准，以往的分布式系统各种问题都可以得到较好的解决。</p><h2 id="微服务设计时的五条宝贵经验"><a href="#微服务设计时的五条宝贵经验" class="headerlink" title="微服务设计时的五条宝贵经验"></a>微服务设计时的五条宝贵经验</h2><p>在著名软件著作《人月神话》中提到，软件世界没有“银弹”，这句话当然适用于架构领域，随着从单体架构过渡到微服务架构，因为将原有系统打散，给系统增加了许多不稳定因素。</p><p><strong>下面我从网络、性能、运维成本、组织架构与集成测试五个方面分别进行阐述。</strong></p><h3 id="跨进程通信带来的新问题"><a href="#跨进程通信带来的新问题" class="headerlink" title="跨进程通信带来的新问题"></a>跨进程通信带来的新问题</h3><p>以往单体应用是在单机中进行进程内通信，通信稳定性相当好。但是打散为分布式系统后，变为进程间通信，往往这个过程还伴随着跨设备的网络访问，架构师在设计时必须考虑上下游系统因为网络因素无法通信的情况，要假设网络是不可靠的，并设计微服务在网络异常时也能进行符合预期的异常处理。以支付模块为例，用户支付成功后系统自动调用短信服务向用户手机发送“订单支付成功”的消息，此时架构师就必须假设短信服务在服务或者网络不可用时不会影响到订单业务的正常执行。</p><h3 id="较高的响应延迟。"><a href="#较高的响应延迟。" class="headerlink" title="较高的响应延迟。"></a>较高的响应延迟。</h3><p>相比传统单体架构进程内通信，跨进程、跨网络的微服务通信在网络传输与消息序列化带来的延迟是不可被忽略的，尤其是在五个以上微服务间消息调用时，网络延迟对于实时系统的影响是很大的。早些年我和军事院校合作了一个雷达仿真训练的系统，因为要模拟“导弹打飞机”的场景，在计算飞行轨道时1毫秒的响应增加都可以会影响到最终的结果，显然这类系统采用分布式设计就不再合适。</p><h3 id="运维成本会直线上升"><a href="#运维成本会直线上升" class="headerlink" title="运维成本会直线上升"></a>运维成本会直线上升</h3><p>早期单体应用因为结构简单，规模也较小，发版时通常面对几台服务器部署几个Jar/War文件就可以了。同时，应用的交付周期也是以周甚至月为单位，此时硬件设备成本与运维人员技术要求都比较低，采用手动部署即可满足要求。而对于微服务架构而言，每一个服务都是可独立运行、独立部署、独立维护的业务单元，再加上互联网时代用户需求的不断变化以及市场的不稳定因素，运维人员每天面对成百上千台服务器发布几十次已是家常便饭，传统手动部署显然已经无法满足互联网的快速变化。</p><h3 id="组织架构层面的调整"><a href="#组织架构层面的调整" class="headerlink" title="组织架构层面的调整"></a>组织架构层面的调整</h3><p>微服务不但是一种架构风格，同样也是一种软件组织模型，以往软件公司会以职能划分研发、测试、运维部门进行独立管理考核，而在微服务的实施过程中，是以业务模块进行团队划分，每一个团队是内聚的，要求可以独立完成从调研到发版的全流程，尽量减少对外界的依赖。如何将传统的职能团队调整为按业务划分的研发团队，同样是对管理者的巨大挑战，要知道人的思想比架构更难改变。</p><h3 id="服务间的集成测试变得举步维艰"><a href="#服务间的集成测试变得举步维艰" class="headerlink" title="服务间的集成测试变得举步维艰"></a>服务间的集成测试变得举步维艰</h3><p>传统单体架构集成测试是将不同的模块按业务流程进行组合，在进程内验证每一种可能性下其模块间协作是否符合预期即可。但对于微服务而言，系统被拆解为很多独立运行的单元，服务间采用接口进行网络通信。要获取准确的测试结果，必须搭建完整的微服务环境，光这一项就需要花费大量的人力物力。同时，因为微服务是跨网络通信，网络延迟、超时、带宽、数据量等因素都将影响最终结果，测试结果易产生偏差。</p><h2 id="微服务最佳实践"><a href="#微服务最佳实践" class="headerlink" title="微服务最佳实践"></a>微服务最佳实践</h2><h3 id="第一点，微服务的划分原则"><a href="#第一点，微服务的划分原则" class="headerlink" title="第一点，微服务的划分原则"></a>第一点，微服务的划分原则</h3><p>将已有系统拆分为多个微服务，本就没有统一的标准。举个例子，一个初创电商公司，要开发一套电商系统，将“促销活动”单独剥离出来作为“促销服务”是没有问题的。但是如果在“淘宝”“京东”这种体量的电商平台，“促销服务”就显得粒度太粗了。可以继续拆解为“价格服务”“优惠券服务”“京豆服务”等更细粒度的小服务，每个服务有专门团队负责维护。</p><p><img src="/2022/05/04/2022-05-04微服务架构设计/6.png" alt="京东商城的微服务业务划分" loading="lazy"></p><center>京东商城的微服务业务划分</center><p>因此，在微服务拆分过程中，我们通常会从业务场景、团队能力、组织架构等多种因素综合考虑，这特别考验架构师的业务能力。一般来说，我们总结出几点通用原则：</p><ul><li><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>每一个微服务只做好一件事，体现出“高内聚、低耦合”，尽量减少对外界环境的依赖。比如，在公司创业之初，完全可将订单与仓储服务进行合并。因为订单与仓储在业务与数据上紧密相关，如果强行拆分会导致出现跨进程通信带来的数据一致性难题。随着业务的发展，仓储的业务职责扩展，派生出许多与订单无紧密联系的功能，到时再将其剥离形成独立的“仓储服务”。</p></li><li><h4 id="服务依赖原则"><a href="#服务依赖原则" class="headerlink" title="服务依赖原则"></a>服务依赖原则</h4><p>避免服务间的循环引用，在设计时就要对服务进行分级，区分核心服务与非核心服务。比如订单服务与短信服务，显然短信服务是非核心服务，服务间调用要遵循“核心服务”到“非核心服务”的方向，不允许出现反向调用。同时，对于核心服务要做好保护，避免非核心服务出现问题影响核心服务的正常运行。</p></li><li><h4 id="Two-Pizza-Team原则"><a href="#Two-Pizza-Team原则" class="headerlink" title="Two Pizza Team原则"></a>Two Pizza Team原则</h4><p>就是说让团队保持在两个比萨能让队员吃饱的小规模的概念。团队要小到让每个成员都能做出显著的贡献，并且相互依赖，有共同目标，以及统一的成功标准。一个微服务团队应涵盖从设计到发布运维的完整生命周期，使团队内部便可以解决大部分任务，从人数上4~6人是比较理想的规模。</p></li></ul><h3 id="第二点，为每一个微服务模块明确使命"><a href="#第二点，为每一个微服务模块明确使命" class="headerlink" title="第二点，为每一个微服务模块明确使命"></a>第二点，为每一个微服务模块明确使命</h3><p>这里推荐一套标准的微服务叙述模板，集中体现“只做好一件事”的原则。</p><blockquote><p>模板<br>XX 微服务用来<br>在出现痛点场景的情况下<br>解决现有的 XX 问题<br>从而达到了 XXX 的效果<br>体现了微服务的价值<br>示例</p></blockquote><blockquote><p>商品检索微服务用来<br>在商品数据全量多维度组合查询的情况下<br>解决了 MySQL 数据库全表扫描查询慢的问题<br>从而让查询响应降低到 50ms 以下<br>有效提升了用户体验</p></blockquote><p>通过这种描述，服务的职责与边界就十分明确，团队便以此为目标确认职责。在实施过程中因为我们是以解决问题为目标，切分时可能会比较细碎。经过漫长时间沉淀，系统中出现了类似于“商品检索服务”“订单检索服务”“商铺检索服务”等多个小服务，这时可以对这些服务形成聚合生成新的“通用检索服务”，以此来控制微服务的整体规模。反之，对于庞大的服务，可以考虑拆分为多个小服务进行细粒度的管理。总之，拆与合是伴随着公司业务的演进而变化的，一切以解决问题为准。</p><h3 id="第三点，微服务确保独立的数据存储"><a href="#第三点，微服务确保独立的数据存储" class="headerlink" title="第三点，微服务确保独立的数据存储"></a>第三点，微服务确保独立的数据存储</h3><p>数据是任何系统最重要的资产。以往单体应用通常会选择 MySQL 这种关系型数据库作为数据的唯一存储，这样做的好处是涉及多表操作时，利用数据库自带的事务机制便可最大程度保证数据完整性。但这样做却存在诸多问题，以下图为例，不同的微服务对数据存储的需求也是不同的，订单服务需要 MySQL 数据保存订单与订单明细；新闻服务需要Elasticsearch提供全文检索支持；朋友圈需要图数据库表达现实世界人际关系；文件存储服务则需要分布式文件系统。如果将所有数据都揉在 MySQL 中使用会变得十分蹩脚，好的做法是为每一个微服务提供符合自身业务特性的数据库。</p><p><img src="/2022/05/04/2022-05-04微服务架构设计/7.png" alt="独立的数据存储" loading="lazy"></p><center>独立的数据存储</center><p>但理想很丰满现实很骨感，在分库后涉及跨库操作会变的难以处理。比如，订单依赖会员数据，原本单库处理时一条 SQL 语句便可实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT order.* , member.* FROM order,member WHERE order.member_id = member.member_id</span><br></pre></td></tr></table></figure><p>但在微服务架构下，因为数据库绝不允许其他团队访问，关联查询只能变为 API 调用形式，程序实现层面比单库复杂不少。<br><img src="/2022/05/04/2022-05-04微服务架构设计/8.png" alt="通过RESTful通信实现数据关联" loading="lazy"></p><center>通过 RESTful 通信实现数据关联</center><p>与之类似，如果涉及多表写入时一致性问题更复杂。</p><p>在拆分为服务后，数据被分散到多库，为保证异构多库的数据一致性是所有分布式应用的巨大挑战，至今没有完美的解决方案，这块内容我在后面课程单独做一个专题进行讲解。</p><h3 id="第四点，服务间通信优先采用聚合器模式"><a href="#第四点，服务间通信优先采用聚合器模式" class="headerlink" title="第四点，服务间通信优先采用聚合器模式"></a>第四点，服务间通信优先采用聚合器模式</h3><p>在微服务间通信时存在两种消息传递模式：链式模式与聚合器模式。下图所展示的是链式模式，请求按业务流程在各个服务间流转，最终处理完成返回客户端。</p><p><img src="/2022/05/04/2022-05-04微服务架构设计/9.png" alt="链式模式" loading="lazy"></p><center>链式模式</center><p>因为请求是按业务流程传递，很容易能被开发人员理解，链式模式成为最常用的服务间通信模式。但链式模式采用串联模式，调用的整体成功率等于单个服务成功率的乘积，假设每个服务可靠性为 90%，一个业务在 4 个服务执行后的最终成功率只有 **90%*90%*90%*90%≈66%**，有将近一半的请求会处理失败，这是无法接受的。此外，链式模式因默认采用同步方式传输，在服务处理完成前应用会一直处于阻塞状态，当调用链较长时，系统整体性能会严重下滑。</p><p><img src="/2022/05/04/2022-05-04微服务架构设计/10.png" alt="聚合器模式" loading="lazy"></p><center>聚合器模式</center><p>聚合器模式则是通过服务作为入口，组装其他服务的调用。以下图为例，因为“订单流程服务”是将其他服务进行聚合操作，所以称其为聚合器模式。以“订单流程服务”为例，将“订单”“支付”“库存”服务进行聚合，一个服务实现了下单、支付、减库存的完整流程。</p><h3 id="第五点，不要强行“微服务”化"><a href="#第五点，不要强行“微服务”化" class="headerlink" title="第五点，不要强行“微服务”化"></a>第五点，不要强行“微服务”化</h3><p>在以前公司任职时因为业务需要，要开发一个工单系统让售后人员在线为客户提供售后服务，但当时因为公司产品已经非常成熟，每天产生的工单只有几十笔，如果做成单体应用配合 Nginx 反向代理，从存储到应用便能满足需求。此任务分配给一位“年轻”的架构师，可能是为了证明实力，他采用了全套微服务技术来“炫技”，并在会议上侃侃而谈。结果老板反问他“你这么设计有必要么，为一个工单系统投入超过10台服务器成本你考虑了吗?” ，当时那场景别提多尴尬了。其实在我看来，微服务也不过是一种方案，没必要盲从。它也没有违背架构的基本规律：架构是解决当前需求和痛点而演进的。在满足需要的前提下，选择合适的而不是选择最好的，合理降低成本才是好架构师该考虑的事情。</p><h2 id="微服务架构的适用场景"><a href="#微服务架构的适用场景" class="headerlink" title="微服务架构的适用场景"></a>微服务架构的适用场景</h2><ul><li><p>新规划的大型业务系统， 这肯定是最适合引入微服务架构的情况了， 微服务强调“高内聚，低耦合”，每一个团队负责一个服务，这就意味着从根本上和传统的整体性应用有本质不同，从规划阶段采用微服务架构是再好不过的。</p></li><li><p>敏捷的小团队系统，公司在大型项目微服务实践前，往往这类边缘化的小项目会起到“试验田”的作用， 引入快速迭代、持续交付等模式，积累适合本公司特点的微服务实践经验，再将这些经验扩大到其他大型项目中。</p></li><li><p>历史的大型留存业务系统，之前多年我一直在金融软件领域工作，在银行内部许多系统已经使用超过10年时间，成百上千个模块错综复杂维护愈发困难，无论架构、框架乃至技术人员都需要更新迭代，但都不可能一次大动手术，这时微服务的“微”就体现出来，重构时可以将某一个部分剥离为微服务独立运行，确保无误后再继续剥离出下一个服务，通过抽丝剥茧一般的剥离，逐步将原有大系统剥离为若干子服务，虽然过程十分痛苦，但这是必须做的事情。</p></li></ul><h2 id="不适合引入微服务的场景"><a href="#不适合引入微服务的场景" class="headerlink" title="不适合引入微服务的场景"></a>不适合引入微服务的场景</h2><ul><li><p>微型项目，前面提到的工单系统，系统压力很小，需求变化也不大，利用单体架构便可以很好解决，使用分布式架构反而增加了架构复杂度，让系统更容易不稳定。</p></li><li><p>对数据响应要求高的系统，就像前面文中提到的“导弹打飞机”的科研项目，对实时性要求极高，那显然是不合适的。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微服务架构设计&quot;&gt;&lt;a href=&quot;#微服务架构设计&quot; class=&quot;headerlink&quot; title=&quot;微服务架构设计&quot;&gt;&lt;/a&gt;微服务架构设计&lt;/h1&gt;&lt;h2 id=&quot;什么是微服务架构&quot;&gt;&lt;a href=&quot;#什么是微服务架构&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue服务端渲染</title>
    <link href="2022/03/13/2022-03-13Vue%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <id>2022/03/13/2022-03-13Vue%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</id>
    <published>2022-03-13T13:14:04.000Z</published>
    <updated>2022-03-13T13:46:07.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端渲染的前端框架"><a href="#客户端渲染的前端框架" class="headerlink" title="客户端渲染的前端框架"></a>客户端渲染的前端框架</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>什么是渲染</li><li>传统的服务端渲染</li><li>客户端渲染</li><li>现代化的服务端渲染（同构渲染）</li></ul><h2 id="SPA单页面应用"><a href="#SPA单页面应用" class="headerlink" title="SPA单页面应用"></a>SPA单页面应用</h2><p>前端工程化，模块化成为当下技术的主流方案，推出了单页面应用，但是单页面通过js在客户端生成html来呈现网页内容，导致首屏加载时间过长，影响用户体验；而且搜索引擎爬取网站html时，SPA是没有内容，因此单页面应用不利于SEO。</p><p><img src="/2022/03/13/2022-03-13Vue服务端渲染/1.png" alt="单页面应用的优缺点" loading="lazy"></p><h2 id="传统服务端渲染"><a href="#传统服务端渲染" class="headerlink" title="传统服务端渲染"></a>传统服务端渲染</h2><p>客户端只负责展示</p><p><img src="/2022/03/13/2022-03-13Vue服务端渲染/2.png" alt="借鉴传统服务端渲染" loading="lazy"></p><h2 id="同构应用"><a href="#同构应用" class="headerlink" title="同构应用"></a>同构应用</h2><ul><li>通过服务端渲染首屏直出，解决SPA应用首屏渲染慢以及不利于SEO问题</li><li>通过客户端渲染接管页面内容交互得到更好的用户体验</li></ul><p>这种方式通常称为现代化的服务端渲染，也叫同构渲染<br>这种方式构建的应用称之为服务端渲染应用或者同构应用<br><img src="/2022/03/13/2022-03-13Vue服务端渲染/3.png" alt="客户端激活为spa" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;客户端渲染的前端框架&quot;&gt;&lt;a href=&quot;#客户端渲染的前端框架&quot; class=&quot;headerlink&quot; title=&quot;客户端渲染的前端框架&quot;&gt;&lt;/a&gt;客户端渲染的前端框架&lt;/h1&gt;&lt;h2 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="2021/12/27/2021-12-27Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>2021/12/27/2021-12-27Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</id>
    <published>2021-12-27T09:03:44.000Z</published>
    <updated>2022-01-03T14:59:48.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-响应式原理模拟"><a href="#Vue-响应式原理模拟" class="headerlink" title="Vue 响应式原理模拟"></a>Vue 响应式原理模拟</h1><h2 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h2><p><strong>模拟一个最小版本 Vue</strong></p><ul><li>Vue<blockquote><p>负责接收初始化的参数（选项）<br>将 data 中的成员注入到 Vue 实例中，并转换成 setter 和 getter 方法<br>调用 Observer 监听 data 中所有属性的变化<br>调用 Compiler 解析指令和差值表达式</p></blockquote></li><li>Observer<blockquote><p>负责把 data 选项中的属性转换成响应式数据<br>data 中的某个属性也是对象，把该属性转换成响应式数据<br>对数据对象中的所有属性进行监听，如果数据发生变化，会获取最新的值，并通知 Dep</p></blockquote></li><li>Compiler<blockquote><p>负责编译模板，解析每个元素中的指令，以及插值表达式，并替换成相应的数据<br>负责页面的首次渲染<br>当数据发生变化后重新渲染视图</p></blockquote></li><li>Dep<blockquote><p>添加 Watcher 观察者，当数据变化时，通知所有的 Watcher 观察者</p></blockquote></li><li>Watcher<blockquote><p>Watcher 内部有 update 方法，负责更新视图<br>自身实例化的时候往Dep对象中添加自己</p></blockquote></li></ul><p><img src="/2021/12/27/2021-12-27Vue响应式原理/%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="整体结构" loading="lazy"></p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.通过属性保存选项的数据</span></span><br><span class="line">    <span class="built_in">this</span>.$options = options || &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.$data = options.data || &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.$el =</span><br><span class="line">      <span class="keyword">typeof</span> options.el === <span class="string">&quot;string&quot;</span></span><br><span class="line">        ? <span class="built_in">document</span>.querySelector(options.el)</span><br><span class="line">        : options.el;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.把data中的成员转换成setter和getter，注入到Vue实例中</span></span><br><span class="line">    <span class="built_in">this</span>._proxyData(<span class="built_in">this</span>.$data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.调用Observer监听data中所有属性的变化</span></span><br><span class="line">    <span class="keyword">new</span> Observer(<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="comment">// 4.调用Compiler解析指令和差值表达式</span></span><br><span class="line">    <span class="keyword">new</span> Compiler(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data中的成员注入到Vue实例中，并转换成setter和getter方法</span></span><br><span class="line">  <span class="function"><span class="title">_proxyData</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历data中的所有属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 把data中的属性注入到Vue实例中</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, key, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> data[key];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (newValue === data[key]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          data[key] = newValue;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历data中的所有属性</span></span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断data是否式对象</span></span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.遍历data对象的所有属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.defineReactive(data, key, data[key])</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">defineReactive</span>(<span class="params">obj, key, val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(val)</span><br><span class="line">    <span class="comment">// 负责收集依赖并发送通知</span></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue === val) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        val = newValue;</span><br><span class="line">        self.walk(newValue)</span><br><span class="line">        <span class="comment">// 发送通知</span></span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.el = vm.$el</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="built_in">this</span>.compile(<span class="built_in">this</span>.el)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译模板，处理文本节点和元素节点</span></span><br><span class="line">  compile (el) &#123;</span><br><span class="line">    <span class="keyword">let</span> childNodes = el.childNodes</span><br><span class="line">    <span class="built_in">Array</span>.from(childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isTextNode(node)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compileText(node)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isElementNode(node)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compileElement(node)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断node节点，是否有子节点，如果有，递归调用compile</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compile(node)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  update (node, key, attrName) &#123;</span><br><span class="line">    <span class="keyword">let</span> updateFn = <span class="built_in">this</span>[attrName + <span class="string">&#x27;Updater&#x27;</span>]</span><br><span class="line">    updateFn &amp;&amp; updateFn.call(<span class="built_in">this</span>, node, <span class="built_in">this</span>.vm[key], key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理v-text 指令</span></span><br><span class="line">  textUpdater (node, value, key) &#123;</span><br><span class="line">    node.textContent = value</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">      node.textContent = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理v-model</span></span><br><span class="line">  modelUpdater (node, value, key) &#123;</span><br><span class="line">    node.value = value</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">      node.value = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 双向绑定</span></span><br><span class="line">    node.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.vm[key] = node.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译元素节点，处理指令</span></span><br><span class="line">  compileElement (node) &#123;</span><br><span class="line">    <span class="comment">// 遍历所有属性节点</span></span><br><span class="line">    <span class="built_in">Array</span>.form(node.attributes).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> attrName = attr.name</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isDirective(attrName)) &#123;</span><br><span class="line">        attrName = attrName。substr(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> key = attr.value</span><br><span class="line">        <span class="built_in">this</span>.update(node, key, attrName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译文本节点，处理插值表达式</span></span><br><span class="line">  compileText (node) &#123;</span><br><span class="line">    <span class="comment">// console.dir(node)</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span></span><br><span class="line">    <span class="keyword">let</span> value = node.textContent</span><br><span class="line">    <span class="keyword">if</span>(reg.test(value)) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = <span class="built_in">RegExp</span>.$1.trim()</span><br><span class="line">      node.textContent = value.replace(reg, <span class="built_in">this</span>.vm[key])</span><br><span class="line">      <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        node.textContent = newValue</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断元素属性是否是指令</span></span><br><span class="line">  isDirective (attrName) &#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;v-&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断节点是否为文本节点</span></span><br><span class="line">  isTextNode (node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断节点是否为元素节点</span></span><br><span class="line">  isElementNode (node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Compiler-1"><a href="#Compiler-1" class="headerlink" title="Compiler"></a>Compiler</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 存储所有的观察者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub &amp;&amp; sub.update) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送通知</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><ul><li>getter方法中通过Dep收集依赖，setter方法中通过dep触发依赖</li><li>Data中每个属性都要创建dep依赖<br><img src="/2021/12/27/2021-12-27Vue响应式原理/Watcher.png" alt="Watcher" loading="lazy"></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm, key, cb</span>) &#123;</span><br><span class="line">    <span class="comment">// data中的属性名称</span></span><br><span class="line">    <span class="built_in">this</span>.key = key</span><br><span class="line">    <span class="comment">// 回调函数负责更新视图</span></span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="comment">// 把watcher对象记录到ep类的静态属性target</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 触发get方法，在get方法中会调用addSub</span></span><br><span class="line">    <span class="built_in">this</span>.oldValue = vm[key]</span><br><span class="line">    <span class="comment">// 防止重复添加</span></span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当数据发生变化时更新视图</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">let</span> newValue = <span class="built_in">this</span>.vm[<span class="built_in">this</span>.key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.oldValue == newValue) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-响应式原理模拟&quot;&gt;&lt;a href=&quot;#Vue-响应式原理模拟&quot; class=&quot;headerlink&quot; title=&quot;Vue 响应式原理模拟&quot;&gt;&lt;/a&gt;Vue 响应式原理模拟&lt;/h1&gt;&lt;h2 id=&quot;整体分析&quot;&gt;&lt;a href=&quot;#整体分析&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>发布订阅模式和观察者模式</title>
    <link href="2021/12/16/2021-12-16%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>2021/12/16/2021-12-16%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-16T06:09:06.000Z</published>
    <updated>2021-12-27T09:20:00.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h1><ul><li>订阅者</li><li>发布者</li><li>信号中心</li></ul><p>我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心发布（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。<strong>这就叫做“发布/订阅模式”（publish-subscribe pattern）</strong></p><h2 id="vue的自定义事件"><a href="#vue的自定义事件" class="headerlink" title="vue的自定义事件"></a>vue的自定义事件</h2><p>  注册事件时，可以注册多个事件名称，也可以给同一个事件，注册多个事件处理函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// vm中以对象的形式存储注册事件 &#123;&#x27;click&#x27;: [fn1, fn2], &#x27;change&#x27;: [fn3]&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件（订阅消息）</span></span><br><span class="line">vm.$on(<span class="string">&#x27;dataChange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;dataChange&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$on(<span class="string">&#x27;dataChange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;dataChange1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件（发布消息）</span></span><br><span class="line"><span class="comment">// $emit 通过事件名称在vm中找到事件处理函数，依次执行事件处理函数</span></span><br><span class="line">vm.$emit(<span class="string">&#x27;dataChange&#x27;</span>)</span><br></pre></td></tr></table></figure><br><h2 id="兄弟组件通信过程"><a href="#兄弟组件通信过程" class="headerlink" title="兄弟组件通信过程"></a>兄弟组件通信过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus,js</span></span><br><span class="line"><span class="comment">// 事件中心</span></span><br><span class="line"><span class="keyword">let</span> eventHub = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentA.vue</span></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="attr">addTodo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发布消息（事件）</span></span><br><span class="line">  eventHub.$emit(<span class="string">&#x27;add-todo&#x27;</span>, &#123; <span class="attr">text</span>: <span class="built_in">this</span>.newTodoText &#125;)</span><br><span class="line">  <span class="built_in">this</span>.newTodoText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ComponentB.vue</span></span><br><span class="line"> <span class="comment">// 订阅者</span></span><br><span class="line"> <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   eventHub.$on(<span class="string">&#x27;add-todo&#x27;</span>, <span class="built_in">this</span>.addTodo)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><h2 id="模拟vue自定义事件"><a href="#模拟vue自定义事件" class="headerlink" title="模拟vue自定义事件"></a>模拟vue自定义事件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件触发器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// &#123; &#x27;click&#x27;: [fn1, fn2], &#x27;change&#x27;: [fn] &#125;</span></span><br><span class="line">    <span class="built_in">this</span>.subs = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 参数设置对象的原型，null表示没有原型</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册事件</span></span><br><span class="line">  $on (eventType, handler) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs[eventType] = <span class="built_in">this</span>.subs[eventType] || []</span><br><span class="line">    <span class="built_in">this</span>.subs[eventType].push(handler)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  $emit (eventType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.subs[eventType]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs[eventType].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">        handler()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> em = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"></span><br><span class="line">em.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">em.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">em.$emit(<span class="string">&#x27;click&#x27;</span>)</span><br></pre></td></tr></table></figure><br><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><ul><li>观察者（订阅者）–Watcher<ul><li>update(): 当事件发生时，具体要做的事情</li></ul></li><li>目标（发布者） –Dep<ul><li>subs 数组：存储所有的观察者</li><li>addSub(): 添加观察者</li><li>notify(): 当事件发生，调用所有观察者的update()方法 </li></ul></li><li>没有事件中心</li></ul><p>vue采用的就是观察者模式，现在模拟一段观察者模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布者 - 目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 记录所有的订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub &amp;&amp; sub.update) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅者 - 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;update&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="keyword">let</span> watcher = <span class="keyword">new</span> Watcher()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加订阅者</span></span><br><span class="line">dep.addSub(watcher)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有的订阅者</span></span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>观察者模式</strong>是由具体目标调度，比如当事件触发，Dep就会去调用观察者的方法，所以观察者模式的发布者和订阅者之间是存在依赖的</p><p><strong>发布/订阅模式</strong>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在</p><p><img src="/2021/12/16/2021-12-16发布订阅模式和观察者模式/1.png" alt="生命周期" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;发布订阅模式&quot;&gt;&lt;a href=&quot;#发布订阅模式&quot; class=&quot;headerlink&quot; title=&quot;发布订阅模式&quot;&gt;&lt;/a&gt;发布订阅模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;订阅者&lt;/li&gt;
&lt;li&gt;发布者&lt;/li&gt;
&lt;li&gt;信号中心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们假</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20211-11-10react设计原理</title>
    <link href="2021/11/10/2021-11-10react%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <id>2021/11/10/2021-11-10react%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-10T13:46:43.000Z</published>
    <updated>2021-11-10T14:53:03.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React设计原理"><a href="#React设计原理" class="headerlink" title="React设计原理"></a>React设计原理</h1><h2 id="Virtual-DOM-及-Diff-算法"><a href="#Virtual-DOM-及-Diff-算法" class="headerlink" title="Virtual DOM 及 Diff 算法"></a>Virtual DOM 及 Diff 算法</h2><ul><li>jsx到底是什么</li><li>DOM操作问题</li><li>什么是Virtual DOM</li><li>Virtual DOM如何提升效率</li><li>创建Virtual DOM</li><li>渲染Virtual DOM对象为DOM对象</li><li>为元素节点添加属性</li><li>渲染组件</li><li>Virtual DOM比对</li><li>ref属性</li><li>key属性</li></ul><p><img src="/2021/11/10/2021-11-10react设计原理/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React设计原理&quot;&gt;&lt;a href=&quot;#React设计原理&quot; class=&quot;headerlink&quot; title=&quot;React设计原理&quot;&gt;&lt;/a&gt;React设计原理&lt;/h1&gt;&lt;h2 id=&quot;Virtual-DOM-及-Diff-算法&quot;&gt;&lt;a href=&quot;#Virt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端工程化 —— 脚手架工具</title>
    <link href="2021/06/06/2021-06-06%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96-%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7/"/>
    <id>2021/06/06/2021-06-06%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96-%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7/</id>
    <published>2021-06-06T03:39:20.000Z</published>
    <updated>2021-07-05T15:02:07.438Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文章内容输入来源：拉勾教育大前端训练营"><a href="#文章内容输入来源：拉勾教育大前端训练营" class="headerlink" title="文章内容输入来源：拉勾教育大前端训练营"></a>文章内容输入来源：拉勾教育大前端训练营</h4><h1 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h1><h2 id="脚手架的本质作用"><a href="#脚手架的本质作用" class="headerlink" title="脚手架的本质作用"></a>脚手架的本质作用</h2><p>创建项目基础结构、提供项目规范和约定</p><ul><li>相同的组织结构</li><li>相同的开发范式</li><li>相同的模块依赖</li><li>相同的工具配置</li><li>相同的基础代码</li></ul><h2 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h2><p>更像脚手架运行平台，可以搭配不同的generator创建任何类型的项目，创建自己的generator，定制属于自己的前端脚手架</p><ul><li><p>在全局范围安装yo</p><blockquote><p>npm install yo –global # or yarn global add yo</p></blockquote></li><li><p>安装对应的generator</p><blockquote><p>npm install generator-node –global # or yarn global add generator-node</p></blockquote></li><li><p>通过yo运行generator</p><blockquote><p>cd path/to/project-dir<br>mkdir my-module<br>yo node</p></blockquote></li></ul><h2 id="Sub-Generator"><a href="#Sub-Generator" class="headerlink" title="Sub Generator"></a>Sub Generator</h2><p>有时候不需要完整的项目结构，在已有项目基础上创建特定类型的文件，使用sub generator生成特定文件</p><ul><li><p>安装 Sub Generator</p><blockquote><p>yo node:cli</p></blockquote></li><li><p>link到全局</p><blockquote><p>yo link</p></blockquote></li><li><p>安装依赖</p><blockquote><p>yarn</p></blockquote></li></ul><h2 id="自定义Generator"><a href="#自定义Generator" class="headerlink" title="自定义Generator"></a>自定义Generator</h2><p>基于自己的基础代码和业务代码，让脚手架去生成这些代码<br>名称命名格式必须是**generator-<name>**的格式</name></p><h3 id="Generator基本结构"><a href="#Generator基本结构" class="headerlink" title="Generator基本结构"></a>Generator基本结构</h3><p><img src="/2021/06/06/2021-06-06前端工程化-脚手架工具/generator.png" alt="generator" loading="lazy"></p><ul><li><p>创建生成器文件夹</p><blockquote><p>mkdir generator-sample<br>cd generator-sample</p></blockquote></li><li><p>创建package.json</p><blockquote><p>yarn init</p></blockquote></li><li><p>安装yeoman-generator 提供生成器基类，提供了一部分工具函数，使生成器创建更加便捷</p><blockquote><p>yarn add yeoman-generator</p></blockquote></li><li><p>创建入口文件</p><blockquote><p>app/index.js</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此文件作为Generator的核心入口</span></span><br><span class="line"><span class="comment">//需要到处一个继承自Yeoman Generator 的类型</span></span><br><span class="line"><span class="comment">//Yeoman Generator在工作时会自动调用我们在此类型中定义的一些生命周期方法</span></span><br><span class="line"><span class="comment">//我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">//yeoman 工作时，生成文件阶段，自动调用此方法</span></span><br><span class="line">    <span class="comment">//通过fs往项目中写入文件</span></span><br><span class="line">    <span class="comment">//此fs比node中fs更强大，高度封装</span></span><br><span class="line">    <span class="built_in">this</span>.fs.write(<span class="comment">//接受两个参数，写入文件的绝对路径，写入文件内容</span></span><br><span class="line">      <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;temp.txt&#x27;</span>),<span class="comment">//destinationPath 获取生成项目目录下的路径</span></span><br><span class="line">      <span class="built_in">Math</span>.random().toString()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用模板去创建多文件或复杂内容文件"><a href="#使用模板去创建多文件或复杂内容文件" class="headerlink" title="使用模板去创建多文件或复杂内容文件"></a>使用模板去创建多文件或复杂内容文件</h4><p>将需要生成的文件放入 app/templates 目录下<br>模板文件可以使用 EJS 模板标记输出数据<br>使用模板时，不需要使用fs来写入文件，可以使用模板引擎的方法</p><h4 id="使用prompting-设置问题、接受用户输入"><a href="#使用prompting-设置问题、接受用户输入" class="headerlink" title="使用prompting() 设置问题、接受用户输入"></a>使用prompting() 设置问题、接受用户输入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  prompting () &#123;</span><br><span class="line">    <span class="comment">// yeoman 在询问用户环节会自动调用此方法</span></span><br><span class="line">    <span class="comment">// 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prompt([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">        <span class="attr">default</span>: <span class="built_in">this</span>.appname<span class="comment">//父类文件夹名称</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">    .then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.answers = answers <span class="comment">//以键对值的方式返回信息</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">//yeoman 工作时，生成文件阶段，自动调用此方法</span></span><br><span class="line">    <span class="comment">//通过fs往项目中写入文件</span></span><br><span class="line">    <span class="comment">//此fs比node中fs更强大，高度封装</span></span><br><span class="line">    <span class="comment">/* this.fs.write(//接受两个参数，写入文件的绝对路径，写入文件内容</span></span><br><span class="line"><span class="comment">      this.destinationPath(&#x27;temp.txt&#x27;),//destinationPath 获取生成项目目录下的路径</span></span><br><span class="line"><span class="comment">      Math.random().toString()</span></span><br><span class="line"><span class="comment">    ) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过模板方式写入文件到目标目录</span></span><br><span class="line">    <span class="comment">//模板文件路径</span></span><br><span class="line">    <span class="keyword">const</span> tpl = <span class="built_in">this</span>.templatePath(<span class="string">&#x27;foo.txt&#x27;</span>)</span><br><span class="line">    <span class="comment">//输出目标路径</span></span><br><span class="line">    <span class="keyword">const</span> outPut = <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;foo.txt&#x27;</span>)</span><br><span class="line">    <span class="comment">//模板数据上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = &#123;<span class="attr">title</span>: <span class="string">&#x27;hello generator&#x27;</span>, <span class="attr">success</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.fs.copyTpl(tpl, outPut, context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tpl1 = <span class="built_in">this</span>.templatePath(<span class="string">&#x27;bar.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> output1 = <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;bar.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> context1 = <span class="built_in">this</span>.answers</span><br><span class="line">    <span class="built_in">this</span>.fs.copyTpl(tpl1, output1, context1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行 yo <name></name></li></ul><h2 id="发布Generator"><a href="#发布Generator" class="headerlink" title="发布Generator"></a>发布Generator</h2><p>发布Generator实际就是发布一个npm模块</p><ul><li><p>托管到公开的源代码仓库<br><img src="/2021/06/06/2021-06-06前端工程化-脚手架工具/publish.png" alt="publish" loading="lazy"></p></li><li><p>发布<br><img src="/2021/06/06/2021-06-06前端工程化-脚手架工具/yarn.png" alt="yarn" loading="lazy"></p></li><li><p>发布成功<br><img src="/2021/06/06/2021-06-06前端工程化-脚手架工具/success.png" alt="success" loading="lazy"></p></li></ul><h2 id="Plop简介"><a href="#Plop简介" class="headerlink" title="Plop简介"></a>Plop简介</h2><p>小型的脚手架工具，用于创建特定文件的脚手架工具，一般集成于项目中，通常同于创建同类型的文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;文章内容输入来源：拉勾教育大前端训练营&quot;&gt;&lt;a href=&quot;#文章内容输入来源：拉勾教育大前端训练营&quot; class=&quot;headerlink&quot; title=&quot;文章内容输入来源：拉勾教育大前端训练营&quot;&gt;&lt;/a&gt;文章内容输入来源：拉勾教育大前端训练营&lt;/h4&gt;&lt;h1 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工程化概述</title>
    <link href="2021/05/07/2021-05-07%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%A6%82%E8%BF%B0/"/>
    <id>2021/05/07/2021-05-07%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%A6%82%E8%BF%B0/</id>
    <published>2021-05-07T10:07:47.000Z</published>
    <updated>2021-08-11T09:29:15.908Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文章内容输入来源：拉勾教育大前端训练营"><a href="#文章内容输入来源：拉勾教育大前端训练营" class="headerlink" title="文章内容输入来源：拉勾教育大前端训练营"></a>文章内容输入来源：拉勾教育大前端训练营</h4><h1 id="工程化概述"><a href="#工程化概述" class="headerlink" title="工程化概述"></a>工程化概述</h1><ul><li>面临的问题<br>技术是为了解决问题而存在的<blockquote><p>使用ES6+ 新特性，但是兼容有问题<br>使用Less / Sass / PostCss增强CSS编程性，但是运行环境不能直接支持<br>使用模块化，组件化的方式提高项目的可维护性，但运行环境不支持<br>部署上线前需要<strong>手动</strong>压缩代码及资源文件，部署过程需要手动上传代码到服务器<br>多人协同开发，无法硬性统一代码风格，从仓库中pull回来的代码质量无法保证<br>部分功能开发时需要等待后端服务接口提前完成</p></blockquote></li></ul><h2 id="工程化表现"><a href="#工程化表现" class="headerlink" title="工程化表现"></a>工程化表现</h2><p>一切以提高效率、降低成本、质量保证为目的的手段都属于【工程化】<br>项目开发流程<br>创建项目 -&gt; 编码 -&gt; 预览/测试 -&gt; 提交</p><div id="flowchart-0" class="flow-chart"></div>+ 创建项目过程中  + 创建项目结构  + 创建特定类型文件<ul><li><p>编码</p><ul><li>格式化代码</li><li>校验代码风格</li><li>编译 / 构建 / 打包</li></ul></li><li><p>预览/编译</p><ul><li>Web Server/Mock</li><li>Live Reloading/HMR</li><li>Source Map</li></ul></li><li><p>提交</p><ul><li>Git Hooks</li><li>Lint-staged</li><li>持续集成</li></ul></li><li><p>部署</p><ul><li>CI / CD</li><li>自动发布</li></ul><p><img src="/2021/05/07/2021-05-07工程化概述/process.png" alt="工程化" loading="lazy"></p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">start=>start: 创建项目|invalidop1=>operation: 编码|invalidop2=>operation: 预览/测试|invalidop3=>operation: 提交|invalidop4=>operation: 部署|invalidio1=>inputoutput: |requestio2=>inputoutput: catch something…|requestio3=>inputoutput: catch something…|requestio4=>inputoutput: catch something…|requeststart(right)->op1(right)->op2(right)->op3(right)->op4(right)->op1(bot)</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;文章内容输入来源：拉勾教育大前端训练营&quot;&gt;&lt;a href=&quot;#文章内容输入来源：拉勾教育大前端训练营&quot; class=&quot;headerlink&quot; title=&quot;文章内容输入来源：拉勾教育大前端训练营&quot;&gt;&lt;/a&gt;文章内容输入来源：拉勾教育大前端训练营&lt;/h4&gt;&lt;h1 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript性能优化 —— 代码优化</title>
    <link href="2021/05/03/2021-05-03JavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>2021/05/03/2021-05-03JavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</id>
    <published>2021-05-03T04:30:41.000Z</published>
    <updated>2021-05-14T03:04:12.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文章内容输入来源：拉勾教育大前端训练营"><a href="#文章内容输入来源：拉勾教育大前端训练营" class="headerlink" title="文章内容输入来源：拉勾教育大前端训练营"></a>文章内容输入来源：拉勾教育大前端训练营</h4><h1 id="JavaScript性能优化"><a href="#JavaScript性能优化" class="headerlink" title="JavaScript性能优化"></a>JavaScript性能优化</h1><p><a class="link" href="https://jsperf.com/">https://jsperf.com/<i class="fas fa-external-link-alt"></i></a><br>Jsperf使用流程</p><ul><li>使用GitHub账号登录</li><li>填写个人信息</li><li>填写详细的测试用例信息（title，slug）</li><li>填写准备代码（DON操作时经常使用）</li><li>填写必要有setup与teardown代码</li></ul><h2 id="慎用全局变量"><a href="#慎用全局变量" class="headerlink" title="慎用全局变量"></a>慎用全局变量</h2><p><strong>为什么要慎用</strong></p><ul><li>全局变量变量定义在全局执行上下文，是所有作用域链的顶端</li><li>全局执行上下文一直存在于上下文执行栈，直到程序退出</li><li>如果某个局部作用域出现了同名变量则会遮蔽或污染全局</li></ul><h2 id="缓存全局变量"><a href="#缓存全局变量" class="headerlink" title="缓存全局变量"></a>缓存全局变量</h2><p><img src="/2021/05/03/2021-05-03JavaScript性能优化-代码优化/cache1.png" alt="缓存对比" loading="lazy"></p><h2 id="通过原型对象新增方法"><a href="#通过原型对象新增方法" class="headerlink" title="通过原型对象新增方法"></a>通过原型对象新增方法</h2><p><img src="/2021/05/03/2021-05-03JavaScript性能优化-代码优化/prototype1.png" alt="原型对比" loading="lazy"></p><h2 id="避开闭包陷阱"><a href="#避开闭包陷阱" class="headerlink" title="避开闭包陷阱"></a>避开闭包陷阱</h2><ul><li>闭包是一种强大的语法</li><li>闭包使用不当很容易出现内存泄漏</li><li>不要为了闭包而闭包</li></ul><p> 将引用清空，便于内存回收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>)</span><br><span class="line">   el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   el = <span class="literal">null</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> foo()</span><br></pre></td></tr></table></figure><h2 id="避免属性访问方法的使用"><a href="#避免属性访问方法的使用" class="headerlink" title="避免属性访问方法的使用"></a>避免属性访问方法的使用</h2><p><img src="/2021/05/03/2021-05-03JavaScript性能优化-代码优化/proto1.png" alt="避免属性访问方法" loading="lazy"></p><h2 id="For循环优化"><a href="#For循环优化" class="headerlink" title="For循环优化"></a>For循环优化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>).fill(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//修改</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = arr.length;i&lt; len;i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="选择最优的循环方法"><a href="#选择最优的循环方法" class="headerlink" title="选择最优的循环方法"></a>选择最优的循环方法</h2><p>forEach、for、for in比较<br><img src="/2021/05/03/2021-05-03JavaScript性能优化-代码优化/array1.png" alt="循环方法比较" loading="lazy"></p><h2 id="文档碎片优化节点添加"><a href="#文档碎片优化节点添加" class="headerlink" title="文档碎片优化节点添加"></a>文档碎片优化节点添加</h2><p><strong>节点的添加操作必然会有回流和重绘，对性能消耗比较大</strong><br><img src="/2021/05/03/2021-05-03JavaScript性能优化-代码优化/createDocumentFragment.png" alt="文档碎片优化节点添加" loading="lazy"></p><h2 id="克隆优化节点操作"><a href="#克隆优化节点操作" class="headerlink" title="克隆优化节点操作"></a>克隆优化节点操作</h2><p><img src="/2021/05/03/2021-05-03JavaScript性能优化-代码优化/clone.png" alt="克隆优化节点操作" loading="lazy"></p><h2 id="直接量替换new-Object"><a href="#直接量替换new-Object" class="headerlink" title="直接量替换new Object"></a>直接量替换new Object</h2><p><img src="/2021/05/03/2021-05-03JavaScript性能优化-代码优化/newobject.png" alt="直接量替换new" loading="lazy"></p><h2 id="JSBench-使用"><a href="#JSBench-使用" class="headerlink" title="JSBench 使用"></a>JSBench 使用</h2><p><a class="link" href="https://jsbench.me/">https://jsbench.me/<i class="fas fa-external-link-alt"></i></a></p><h2 id="堆栈中代码执行流程"><a href="#堆栈中代码执行流程" class="headerlink" title="堆栈中代码执行流程"></a>堆栈中代码执行流程</h2><p>JS代码在开始执行后在堆内存中创建执行环境栈，用于存放执行上下文<br>执行时，先创建全局执行上下文,VO:变量对象<strong>基本对象存在栈中</strong>，foo是引用类型，在堆区中开辟一片区域,地址：AB1<br>foo函数被调用，开辟一个新的执行上下文，函数创建一个this指向，初始化作用域链，baz是引用类型，在堆区中开辟一片区域,地址：AB2，AO中初始化参数<br>fn指向AB2,产生闭包，EC（foo）空间不被释放，按照浏览器执行机制，把EC（foo）往下压，压到最后<br>执行fn(3)，产生一个新的执行上下文，AO中初始化参数，沿着作用域链找到参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b+c)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> baz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = foo(<span class="number">2</span>)</span><br><span class="line">fn(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><br><p><img src="/2021/05/03/2021-05-03JavaScript性能优化-代码优化/jsprocess.png" alt="堆栈中代码执行流程" loading="lazy"></p><h2 id="减少判断层级"><a href="#减少判断层级" class="headerlink" title="减少判断层级"></a>减少判断层级</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params">part, chapter</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parts = [<span class="string">&#x27;ES2016&#x27;</span>, <span class="string">&#x27;Vue&#x27;</span>, <span class="string">&#x27;React&#x27;</span>, <span class="string">&#x27;Node&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span>(part)&#123;</span><br><span class="line">    <span class="keyword">if</span>(parts.includes(part))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;属于当前课程&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span>(chapter &gt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;您需要提供VIP身份&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请确认模块信息&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params">part, chapter</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parts = [<span class="string">&#x27;ES2016&#x27;</span>, <span class="string">&#x27;Vue&#x27;</span>, <span class="string">&#x27;React&#x27;</span>, <span class="string">&#x27;Node&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span>(!part)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请确认模块信息&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(parts.includes(part)) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;属于当前课程&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span>(chapter &gt; <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;您需要提供VIP身份&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="减少作用域链查找层级"><a href="#减少作用域链查找层级" class="headerlink" title="减少作用域链查找层级"></a>减少作用域链查找层级</h2><p>优化后：以空间换时间，具体情况要考虑产品</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;new Name&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">28</span></span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;new Name&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">28</span></span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="减少数据读取次数"><a href="#减少数据读取次数" class="headerlink" title="减少数据读取次数"></a>减少数据读取次数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;skip&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasEle</span>(<span class="params">ele, cls</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ele.className === cls</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasEle</span>(<span class="params">ele, cls</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clsName = ele.className</span><br><span class="line">  <span class="keyword">return</span> clsName === cls</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="字面量与构造式"><a href="#字面量与构造式" class="headerlink" title="字面量与构造式"></a>字面量与构造式</h2><p>字面量创造基本类型差异较大<br>构造式会调用函数，而字面量直接在堆区中开辟空间，会更快<br>构造式是一个对象可以沿原型链调用方法，而字面量会内部转换成一个对象<br>扩容时构造式会更好些</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  obj.name = <span class="string">&#x27;name&#x27;</span></span><br><span class="line">  obj.age = <span class="string">&#x27;age&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&#x27;age&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><br><h2 id="减少循环体中活动"><a href="#减少循环体中活动" class="headerlink" title="减少循环体中活动"></a>减少循环体中活动</h2><p>每次循环用到的不变的，放到循环外</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">  <span class="keyword">var</span> len = arr.length</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">  <span class="keyword">var</span> len = arr.length</span><br><span class="line">  <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[len])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="减少声明及语句数"><a href="#减少声明及语句数" class="headerlink" title="减少声明及语句数"></a>减少声明及语句数</h2><p>之前，数据访问减少层级<br>示例中<br>优化前，代码多，词法分析时，代码没有执行，js编译器按照一定规则进行拆分，拆除w，h，空格，等号，这些单处拿出变成词法单元，之后做语法分析，最终展示st语法树，再去转成代码去执行<br>优化后，只对ele做词法分析，return中的只是数据访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> w = ele.offsetWidth</span><br><span class="line">  <span class="keyword">let</span> h = ele.offsetHeight</span><br><span class="line">  <span class="keyword">return</span> w * h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ele.offsetWidth * ele.offsetHeight</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>语句数越少，执行越快，但是不便于代码维护</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">var</span> name  = <span class="string">&#x27;name&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="string">&#x27;age&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> slogan = <span class="string">&#x27;slogan&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> name + age + slogan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name  = <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">      age = <span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">      slogan = <span class="string">&#x27;slogan&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> name + age + slogan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="采用事件绑定"><a href="#采用事件绑定" class="headerlink" title="采用事件绑定"></a>采用事件绑定</h2><p>利用事件冒泡的机制将子元素的事件绑定到父元素上，利用父元素完成事件的监听<br>好处：解决内存的大量占用，减少事件注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTxt</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = ev.target</span><br><span class="line">  <span class="keyword">if</span>(obj.nodeName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> list)&#123;</span><br><span class="line">  item.onclick = showTxt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line"></span><br><span class="line">oUl.addEventListener(<span class="string">&#x27;click&#x27;</span>, showTxt, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;文章内容输入来源：拉勾教育大前端训练营&quot;&gt;&lt;a href=&quot;#文章内容输入来源：拉勾教育大前端训练营&quot; class=&quot;headerlink&quot; title=&quot;文章内容输入来源：拉勾教育大前端训练营&quot;&gt;&lt;/a&gt;文章内容输入来源：拉勾教育大前端训练营&lt;/h4&gt;&lt;h1 i</summary>
      
    
    
    
    
  </entry>
  
</feed>
